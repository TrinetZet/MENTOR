 <!DOCTYPE html><html lang="ru">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Mentor - PRO</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <style>

        :root {
    --primary: #007bff;
    --primary-hover: #0056b3;
    --success: #28a745;
    --danger: #dc3545;
    --warning: #05bebe;
    --bg: #ffffff; /* Убедитесь, что здесь белый */
    --card-bg: #ffffff;
    --text: #333;
    --border: #e0e0e0;
    --radius: 8px;
    --group-and: #e6fffa;
    --group-and-border: #08b18a;
    --group-or: #fff3e0;
    --group-or-border: #ff9800;
    --group-seq: #f3e5f5;
    --group-seq-border: #9c27b0;
    /* Градиенты для кнопок */
    --btn-gradient-primary: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    --btn-gradient-success: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
    --btn-gradient-danger: linear-gradient(135deg, #999999 0%, #696969 100%);
    --btn-gradient-warning: linear-gradient(135deg, #05bebe 0%, #049898 100%);
    
    /* Градиенты для групп */
    --group-and-gradient: linear-gradient(135deg, #e6fffa 0%, #b2f2e6 100%);
    --group-or-gradient: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
    --group-seq-gradient: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
    
    /* Цвета для стеклянного эффекта */
    --glass-bg: rgba(255, 255, 255, 0.15);
    --glass-border: rgba(255, 255, 255, 0.2);
    --glass-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
}

/* ДОБАВЬТЕ ЭТОТ БЛОК */
body, html {
    background-color: #ffffff !important;
    margin: 0;
    padding: 0;
}

#Mentor-app {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    color: var(--text);
    background: #ffffff; /* Явно прописываем белый */
    padding: 25px;
    border-radius: 12px;
    max-width: 1400px;
    margin: 0 auto;
    /* Убираем или осветляем тень, если она дает "грязный" эффект вокруг */
    box-sizing: border-box;
}

/* --- ГЛУБОКАЯ АДАПТАЦИЯ ИНТЕРФЕЙСА --- */

/* 1. Общие правила для всех разрешений */
html {
    scroll-behavior: smooth;
}

body {
    transition: zoom 0.2s ease-in-out; /* Плавный переход при изменении размера окна */
    -moz-transform: scale(0.9); /* Фикс для Firefox, так как он не поддерживает zoom */
    -moz-transform-origin: 0 0;
}

/* 2. ОГРОМНЫЕ МОНИТОРЫ (4K, 2K) */
@media screen and (min-width: 1921px) {
    body {
        zoom: 1.1; /* Чуть увеличиваем, чтобы не было слишком мелко */
        max-width: 2000px;
        margin: 0 auto; /* Центрируем приложение на сверхшироких экранах */
    }
}

/* 3. СТАНДАРТНЫЙ FULL HD (1920x1080) */
@media screen and (min-width: 1401px) and (max-width: 1920px) {
    body {
        zoom: 0.9; 
    }
}

/* 4. НОУТБУКИ (1366x768, 1440x900) */
@media screen and (max-width: 1400px) {
    body {
        zoom: 0.75; /* 67% может быть слишком мелко для чтения, 75% — золотая середина */
    }
    
    /* Увеличиваем важные элементы взаимодействия обратно */
    .hp-btn, .hp-tab {
        transform: scale(1.1); 
        transform-origin: center;
    }

    #floating-action-panel {
        bottom: 20px;
        right: 20px;
        zoom: 1.15;
    }
}

/* 5. ПЛАНШЕТЫ И МАЛЕНЬКИЕ ЭКРАНЫ */
@media screen and (max-width: 1024px) {
    body {
        zoom: 1; /* Отключаем общий зум, переходим на нативную адаптивность */
    }
    
    /* Переводим таблицы в режим скролла, чтобы они не сжимались в кашу */
    .hp-table-wrapper {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
    
    /* Делаем табы более крупными для нажатия пальцем */
    .hp-tab {
        padding: 12px 15px;
        font-size: 14px;
    }
}

/* --- ФИКСЫ ИНТЕРФЕЙСА ПРИ МАСШТАБИРОВАНИИ --- */

/* Модальные окна */
.modal-overlay {
    display: flex;
    align-items: center; /* Центрируем по вертикали */
    justify-content: center;
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(2px); /* Эффект размытия задника */
}

.modal-content {
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    border-radius: var(--radius);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    /* Исправляем искажения координат при зуме */
    transform: translateZ(0); 
}

/* Фикс для графиков Chart.js */
canvas {
    max-width: 100% !important;
    height: auto !important;
}

/* Специальный класс для скрытия сложных элементов в Lite-версии на мелких экранах */
@media screen and (max-width: 600px) {
    .hide-mobile {
        display: none !important;
    }
}



.hp-tabs {
    display: flex;
    align-items: center; /* Добавлено: центрируем элементы по вертикали */
    border-bottom: 2px solid var(--border);
    margin-bottom: 25px;
    padding-right: 10px; /* Добавлено: небольшой отступ справа */
}

.hp-tabs-actions {
    margin-left: auto; /* Это магическое свойство толкает блок вправо */
    display: flex;
    gap: 10px;
}


        .hp-tab {

            padding: 12px 25px;

            cursor: pointer;

            font-weight: 600;

            color: #777;

            border-bottom: 3px solid transparent;

            transition: all 0.2s;

            font-size: 14px;

        }



        .hp-tab:hover {

            color: var(--primary);

            background: rgba(0, 123, 255, 0.05);

        }



        .hp-tab.active {

            color: var(--primary);

            border-bottom-color: var(--primary);

        }



        .hp-content {

            display: none;

            animation: fadeIn 0.3s ease-out;

        }



        .hp-content.active {

            display: block;

        }



        @keyframes fadeIn {

            from {

                opacity: 0;

                transform: translateY(5px);

            }



            to {

                opacity: 1;

                transform: translateY(0);

            }

        }



        .hp-controls-row {

            display: flex;

            gap: 15px;

            align-items: flex-end;

            flex-wrap: wrap;

            margin-bottom: 20px;

        }



       .hp-form-group {
    position: relative; /* Это точка привязки для выпадающего списка */
    margin-bottom: 15px;
}



        .hp-form-group label {

            font-size: 11px;

            font-weight: 700;

            color: #666;

            margin-bottom: 5px;

            text-transform: uppercase;

            letter-spacing: 0.5px;

        }



        .hp-input {

            padding: 10px 12px;

            border: 1px solid #ccc;

            border-radius: var(--radius);

            height: 40px;

            font-size: 14px;

            width: 100%;

            box-sizing: border-box;

            transition: 0.2s;

        }



        .hp-input:focus {

            border-color: var(--primary);

            outline: none;

            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);

        }



        .hp-input-sm {

            height: 30px !important;

            padding: 4px 8px !important;

            font-size: 13px !important;

            width: 100% !important;

            line-height: 1;

            box-sizing: border-box;

        }



        /* Основной стиль кнопок */
.hp-btn {
    height: 40px;
    padding: 0 20px;
    border: none;
    border-radius: var(--radius);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    color: white;
    background: var(--btn-gradient-primary);
    white-space: nowrap;
    position: relative;
    overflow: hidden;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(0, 123, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.hp-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.7s ease;
}

.hp-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 123, 255, 0.3);
}

.hp-btn:hover::before {
    left: 100%;
}

.hp-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(0, 123, 255, 0.2);
    transition: all 0.1s ease;
}

/* Цветовые варианты */
.hp-btn-success {
    background: var(--btn-gradient-success);
    box-shadow: 0 4px 15px rgba(40, 167, 69, 0.2);
}

.hp-btn-success:hover {
    box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
}

.hp-btn-danger {
    background: var(--btn-gradient-danger);
}

.hp-btn-danger:hover {
    box-shadow: 0 6px 20px rgba(220, 53, 69, 0.3);
}

.hp-btn-warning {
    background: var(--btn-gradient-warning);
    box-shadow: 0 4px 15px rgba(5, 190, 190, 0.2);
}

.hp-btn-warning:hover {
    box-shadow: 0 6px 20px rgba(5, 190, 190, 0.3);
}



        .hp-btn-sm {

            height: 30px;

            padding: 0 10px;

            font-size: 12px;

        }



        .hp-table-wrapper {

            background: var(--card-bg);

            border-radius: var(--radius);

            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);

            border: 1px solid var(--border);

        }



        table {

            width: 100%;

            border-collapse: collapse;

        }



        th,

        td {

            padding: 14px 18px;

            text-align: left;

            border-bottom: 1px solid #eee;

            font-size: 14px;

            vertical-align: middle;

        }



        th {

            background: #f8f9fa;

            font-weight: 600;

            color: #555;

        }



        tr:last-child td {

            border-bottom: none;

        }



        tr:hover td {

            background: #fafafa;

        }



        .hp-tag {

            display: inline-flex;

            align-items: center;

            background: #e9ecef;

            padding: 4px 10px;

            border-radius: 20px;

            font-size: 12px;

            margin: 2px;

            color: #495057;

        }



        .hp-tag b {

            cursor: pointer;

            margin-left: 6px;

            color: #adb5bd;

            font-size: 14px;

        }



        .hp-tag b:hover {

            color: var(--danger);

        }



        .tag-blue {

            background: #e7f5ff;

            color: #004085;

        }



        .tag-green {

            background: #d4edda;

            color: #155724;

        }



        .tag-orange {

            background: #fff3e0;

            color: #e65100;

        }



/* Стили для выпадающих списков */
.hp-dropdown {
    position: absolute;      /* Абсолютно относительно hp-form-group */
    top: 100%;               /* Сразу под полем ввода */
    left: 0;
    width: 100%;             /* Ширина равна ширине поля */
    background: white;
    border: 1px solid var(--border);
    border-radius: 0 0 4px 4px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 10000;          /* Очень высокий z-index, чтобы быть поверх всего */
    display: none;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

.hp-dropdown-item {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    font-size: 13px;
}

.hp-dropdown-item:hover {
    background-color: #f5f5f5;
}

.hp-dropdown-item:last-child {
    border-bottom: none;
}



        #hp-toast-container {

            position: fixed;

            bottom: 20px;

            right: 20px;

            z-index: 10000;

            display: flex;

            flex-direction: column;

            gap: 10px;

        }



        .hp-toast {

            background: #333;

            color: #fff;

            padding: 12px 20px;

            border-radius: 6px;

            font-size: 14px;

            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);

            animation: slideIn 0.3s ease-out;

            min-width: 200px;

        }



        @keyframes slideIn {

            from {

                transform: translateX(100%);

                opacity: 0;

            }



            to {

                transform: translateX(0);

                opacity: 1;

            }

        }



        /* GROUP STYLES */

        .drag-handle {

            width: 30px;

            height: 30px;

            background: #f8f9fa;

            border: 2px solid #dee2e6;

            border-radius: 6px;

            display: flex;

            align-items: center;

            justify-content: center;

            cursor: grab;

            flex-shrink: 0;

            font-size: 16px;

            color: #666;

            user-select: none;

        }



        .drag-handle:active {

            cursor: grabbing;

        }



        .step-item {

            background: white;

            border: 2px solid #e0e0e0;

            border-radius: var(--radius);

            padding: 15px;

            display: flex;

            align-items: center;

            gap: 15px;

            position: relative;

            transition: all 0.2s;

            margin-bottom: 10px;

        }



        .step-item:hover {

            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

        }



        .step-item.dragging {

            opacity: 0.3;

            cursor: grabbing;

        }



        .step-number {

            font-weight: 700;

            font-size: 16px;

            color: var(--primary);

            min-width: 30px;

            flex-shrink: 0;

        }



        .step-content {

            flex: 1;

            display: flex;

            flex-direction: column;

            gap: 5px;

        }



        .step-name {

            font-weight: 600;

            color: var(--text);

        }



        .step-time {

            font-size: 12px;

            color: #666;

        }



        .step-actions {

            display: flex;

            gap: 8px;

            flex-shrink: 0;

        }



/* Базовое состояние: зона полностью схлопнута и невидима */
.drop-zone {
    height: 0;
    margin: 0;
    padding: 0;
    background: transparent;
    border: 2px solid transparent;
    border-radius: 10px;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); /* Быстрый, но плавный переход */
    position: relative;
    overflow: hidden; /* Чтобы контент внутри не вылезал раньше времени */
    pointer-events: auto; /* Важно для регистрации события dragover */
}

/* Состояние, когда на зону навели перетаскиваемый элемент */
.drop-zone.drag-over {
    height: 70px; 
    margin: 12px 0;
    background: rgba(0, 123, 255, 0.1);
    border: 2px dashed var(--primary);
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--primary);
    box-shadow: 0 4px 15px rgba(0, 123, 255, 0.15);
    z-index: 10;
    backdrop-filter: blur(4px);
}

/* Текст внутри зоны появляется только при активации */
.drop-zone.drag-over::after {
    content: "Переместить сюда";
    font-size: 14px;
    font-weight: 600;
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

/* Убираем анимацию расширения при ховере на список, 
   теперь зоны реагируют ТОЛЬКО на реальный Drag & Drop */
.steps-list:hover .drop-zone:not(.drag-over) {
    height: 0;
    margin: 0;
    background: transparent;
}

/* Стили для самого перетаскиваемого элемента */
.step-item.dragging {
    opacity: 0.5;
    transform: scale(0.98); /* Слегка уменьшаем, как будто элемент "оторвался" от поверхности */
    filter: grayscale(0.5);
}

.group-container.dragging {
    opacity: 0.6;
    border-style: dashed !important;
}

/* Адаптация для вложенных зон внутри групп */
.group-container .drop-zone.drag-over {
    height: 60px;
    margin: 10px;
}



       /* Стили для групп */
/* ОБЩИЕ СТИЛИ ДЛЯ ВСЕХ ГРУПП */
.group-container {
    border: 2px solid var(--group-and-border); /* Увеличил толщину с 2px до 3px */
    border-radius: var(--radius);
    padding: 35px 20px 20px 20px;
    background: var(--group-and-gradient);
    position: relative;
    margin: 25px 0 10px 0;
    width: 100%;
    box-sizing: border-box;
    display: block;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Добавил тень для лучшего выделения */
}

/* ЯВНОЕ УКАЗАНИЕ ЦВЕТА ДЛЯ КАЖДОГО ТИПА */
.group-container.group-and {
    border: 1px solid #005c47; /* Еще более темный зеленый */
    background: var(--group-and-gradient);
}

.group-container.group-or {
    border: 1px solid #ff9800; /* Оранжевый - оставляем как есть */
    background: var(--group-or-gradient);
}

.group-container.group-seq {
    border: 1px solid #7b1fa2; /* Фиолетовый - оставляем как есть */
    background: var(--group-seq-gradient);
}

/* Заголовок группы */
.group-header {
    position: absolute;
    /* Чуть опустим, чтобы он "сидел" прямо на рамке (было -30px, сделаем -18px) */
    top: -18px; 
    left: 25px; 
    
    background: white; /* Чистый белый фон для лучшей читаемости слоев */
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
    z-index: 5; 
}


.group-container .group-container {
    /* Если группа внутри группы, уменьшаем отступы, чтобы матрешка не была слишком огромной */
    margin-top: 30px; 
    padding: 30px 15px 15px 15px;
}

.group-header.group-and {
    color: #005a40; /* Сделаем чуть темнее для лучшей читаемости */
    border: 2px solid var(--group-and-border);
}

.group-header.group-or {
    color: #e65100;
    border: 2px solid var(--group-or-border);
}

.group-header.group-seq {
    color: #7b1fa2;
    border: 2px solid var(--group-seq-border);
}



       /* Кнопка изменения типа группы */
.group-type-selector {
    border: none;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.6) 100%);
    font-size: 11px;
    font-weight: 700;
    cursor: pointer;
    padding: 6px 12px;
    border-radius: 20px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    position: relative;
    overflow: hidden;
}

.group-type-selector::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: left 0.5s ease;
}

.group-type-selector:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.group-type-selector:hover::before {
    left: 100%;
}

/* Кнопка закрытия группы */
/* Кнопка закрытия группы — современный стиль */
.group-close {
    cursor: pointer;
    font-size: 16px;
    font-weight: 700;
    color: #dc3545;
    
    /* Плавный переход для всех свойств с эффектом пружины */
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(220, 53, 69, 0.15);
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.group-close:hover {
    background: #dc3545;
    color: #fff;
    /* Эффект легкого "всплытия" */
    transform: translateY(-2px) scale(1.1);
    /* Глубокая мягкая тень */
    box-shadow: 0 6px 15px rgba(220, 53, 69, 0.3);
    border-color: transparent;
}

/* Эффект активного нажатия (кнопка чуть вдавливается) */
.group-close:active {
    transform: translateY(0) scale(0.95);
    transition: all 0.1s;
}

/* Необязательно: можно добавить микро-анимацию самого крестика */
.group-close:hover::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.1);
    top: 0;
    left: 0;
}

/* Анимация при изменении типа группы */
@keyframes groupTypeChange {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.group-type-selector.changing {
    animation: groupTypeChange 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Анимация при расформировании группы */
@keyframes groupUngroup {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(0.95); }
    100% { opacity: 0; transform: scale(0.9); }
}

.group-container.ungrouping {
    animation: groupUngroup 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}



        .hp-modal-overlay {

            position: fixed !important;

            top: 0;

            left: 0;

            right: 0;

            bottom: 0;

            background: rgba(0, 0, 0, 0.5);

            display: flex;

            align-items: center;

            justify-content: center;

            z-index: 9999999;

        }



        .hp-modal {

            background: white;

            padding: 30px;

            border-radius: var(--radius);

            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);

            max-width: 600px;

            width: 90%;

            max-height: 80vh;

            overflow-y: auto;

        }



        .hp-modal h3 {

            margin-bottom: 20px;

            color: var(--text);

        }



        .hp-modal p {

            margin-bottom: 20px;

            color: #666;

            line-height: 1.6;

        }



        .hp-modal-buttons {

            display: flex;

            gap: 10px;

            justify-content: flex-end;

            margin-top: 20px;

        }



        .checkbox-list {

            display: flex;

            flex-direction: column;

            gap: 10px;

            margin: 20px 0;

        }



        .checkbox-item {

            display: flex;

            align-items: center;

            gap: 10px;

            padding: 12px;

            border: 2px solid #e0e0e0;

            border-radius: var(--radius);

            cursor: pointer;

            transition: all 0.2s;

        }



        .checkbox-item:hover {

            background: #f8f9fa;

            border-color: var(--primary);

        }



        .checkbox-item.selected {

            background: rgba(0, 123, 255, 0.1);

            border-color: var(--primary);

        }



        .checkbox-item input[type="checkbox"] {

            width: 20px;

            height: 20px;

            cursor: pointer;

        }



        .checkbox-item-content {

            flex: 1;

        }



        .checkbox-item-title {

            font-weight: 600;

            color: var(--text);

            margin-bottom: 3px;

        }



        .checkbox-item-subtitle {

            font-size: 12px;

            color: #666;

        }



        .checkbox-item-badge {

            padding: 4px 8px;

            border-radius: 4px;

            font-size: 11px;

            font-weight: 700;

        }



        .checkbox-item-badge.step {

            background: #e7f5ff;

            color: var(--primary);

        }



        .checkbox-item-badge.group-and {

            background: var(--group-and);

            color: #0ca678;

            border: 1px solid var(--group-and-border);

        }



        .checkbox-item-badge.group-or {

            background: var(--group-or);

            color: #e65100;

            border: 1px solid var(--group-or-border);

        }



        .checkbox-item-badge.group-seq {

            background: var(--group-seq);

            color: #7b1fa2;

            border: 1px solid var(--group-seq-border);

        }



        .action-description {

            background: #fff3cd;

            border-left: 4px solid var(--warning);

            padding: 15px;

            border-radius: var(--radius);

            margin: 15px 0;

            font-size: 14px;

            color: #2a3535;

        }



        .action-description strong {

            display: block;

            margin-bottom: 5px;

        }



        .time-input-group {

            display: flex;

            gap: 10px;

        }



        .time-input-group .hp-form-group {

            flex: 1;

        }
        
        /* Делаем контейнеры графиков чуть выше для воздуха */
canvas {
    min-height: 300px;
    max-height: 400px;
    width: 100% !important;
}

/* Добавьте в конец стилей */
.tooltip {
    position: relative;
    cursor: help;
}

.tooltip:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 100;
}

/* Фиксированные размеры для колонок таблицы этапов */
#table-steps {
    table-layout: fixed;
    width: 100%;
}

/* Задаем фиксированные ширины для колонок */
#table-steps th:nth-child(1),
#table-steps td:nth-child(1) {
    width: 60px; /* ID */
}

#table-steps th:nth-child(2),
#table-steps td:nth-child(2) {
    width: 200px; /* Действие */
}

#table-steps th:nth-child(3),
#table-steps td:nth-child(3) {
    width: 150px; /* Ответственный */
}

#table-steps th:nth-child(4),
#table-steps td:nth-child(4) {
    width: 250px; /* Время - фиксированная ширина */
    min-width: 250px;
    white-space: nowrap; /* Запрещаем перенос строк */
}

#table-steps th:nth-child(5),
#table-steps td:nth-child(5) {
    width: 80px; /* Входы */
    min-width: 80px;
}

#table-steps th:nth-child(6),
#table-steps td:nth-child(6) {
    width: 80px; /* Выходы */
    min-width: 80px;
}

#table-steps th:nth-child(7),
#table-steps td:nth-child(7) {
    width: 80px; /* Действия */
}

/* Стили для контейнера времени */
#table-steps td:nth-child(4) > div {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: nowrap; /* Запрещаем перенос */
    justify-content: flex-start;
}

/* Фиксированная ширина для полей ввода времени */
#table-steps td:nth-child(4) .hp-input-sm {
    width: 47px !important;
    min-width: 40px !important;
    flex-shrink: 0; /* Запрещаем сжатие */
}

/* Стили для подписей "ч" и "м" */
#table-steps td:nth-child(4) div > span {
    white-space: nowrap;
    flex-shrink: 0;
}

/* Обеспечиваем прокрутку для колонок с ресурсами при необходимости */
#table-steps td:nth-child(5),
#table-steps td:nth-child(6) {
    overflow: auto;
    max-height: 80px;
}

#table-steps td:nth-child(5) .hp-tag,
#table-steps td:nth-child(6) .hp-tag {
    display: inline-block;
    max-width: 160px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-bottom: 2px;
}

/* Добавьте в конец секции стилей */
#chart-decomp-cost-min,
#chart-decomp-cost-avg,
#chart-decomp-cost-max,
#chart-decomp-time-min,
#chart-decomp-time-avg,
#chart-decomp-time-max,
#chart-decomp-mh-min,
#chart-decomp-mh-avg,
#chart-decomp-mh-max {
    min-height: 250px;
    max-height: 300px;
    width: 100% !important;
}

/* Стили для вертикального расположения графиков декомпозиции */
#decomposition-charts-vertical {
    display: flex;
    flex-direction: column;
    gap: 30px;
}

.decomp-chart-group {
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #eee;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
}

.decomp-chart-group h4 {
    margin: 0 0 15px 0;
    color: #333;
    font-size: 16px;
    text-align: center;
    border-bottom: 2px solid #f0f0f0;
    padding-bottom: 10px;
}

.decomp-chart-row {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
}

.decomp-chart-item {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.decomp-chart-item h5 {
    margin: 0 0 10px 0;
    color: #555;
    font-size: 14px;
    text-align: center;
    font-weight: 600;
}

.decomp-chart-item canvas {
    min-height: 350px !important;
    max-height: 400px !important;
    width: 100% !important;
    flex: 1;
}

.diagonal-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
    font-size: 12px;
}

.diagonal-stats .stat-label {
    color: #666;
    font-weight: 600;
}

.diagonal-stats .stat-value {
    color: #007bff;
    font-weight: 700;
    margin-right: 15px;
}

/* Цветовая дифференциация для значений отклонений */
.diagonal-stats .stat-value[style*="color"] {
    padding: 2px 6px;
    border-radius: 3px;
    font-weight: bold;
}

/* Зеленый для низких отклонений (хорошо) */
.diagonal-stats .stat-value.low {
    background-color: rgba(40, 167, 69, 0.1);
    color: #28a745 !important;
}

/* Желтый для средних отклонений (приемлемо) */
.diagonal-stats .stat-value.medium {
    background-color: rgba(255, 193, 7, 0.1);
    color: #ffc107 !important;
}

/* Красный для высоких отклонений (плохо) */
.diagonal-stats .stat-value.high {
    background-color: rgba(220, 53, 69, 0.1);
    color: #dc3545 !important;
}

/* Вертикальное расположение графиков декомпозиции */
.decomp-chart-vertical-item {
    background: #fff;
    padding: 25px;
    border-radius: 8px;
    border: 1px solid #eee;
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    margin-bottom: 25px;
    width: 100%;
}

.decomp-chart-vertical-item:last-child {
    margin-bottom: 0;
}

.decomp-chart-vertical-item h5 {
    margin: 0 0 15px 0;
    color: #555;
    font-size: 16px;
    text-align: center;
    font-weight: 600;
    border-bottom: 2px solid #f0f0f0;
    padding-bottom: 10px;
}

.decomp-chart-vertical-item canvas {
    min-height: 350px !important;
    max-height: 350px !important;
    width: 100% !important;
    margin-bottom: 15px;
}

/* Статистика под графиками */
.decomp-chart-vertical-item .diagonal-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 15px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
    font-size: 13px;
    justify-content: center;
}

.decomp-chart-vertical-item .stat-label {
    color: #666;
    font-weight: 600;
    margin-right: 5px;
}

.decomp-chart-vertical-item .stat-value {
    color: #007bff;
    font-weight: 700;
    margin-right: 20px;
    padding: 4px 8px;
    border-radius: 4px;
    background: rgba(0, 123, 255, 0.1);
}

/* Цветовая дифференциация для значений отклонений */
.decomp-chart-vertical-item .stat-value.low {
    background-color: rgba(40, 167, 69, 0.1);
    color: #28a745 !important;
}

.decomp-chart-vertical-item .stat-value.medium {
    background-color: rgba(255, 193, 7, 0.1);
    color: #ffc107 !important;
}

.decomp-chart-vertical-item .stat-value.high {
    background-color: rgba(220, 53, 69, 0.1);
    color: #dc3545 !important;
}

/* Убираем старые горизонтальные стили */
.decomp-chart-row {
    display: none; /* Скрываем горизонтальное расположение */
}


/* Вертикальное расположение графиков декомпозиции */
.decomp-chart-group {
    margin-bottom: 40px;
    width: 100%;
    max-width: 1310px;
}

.decomp-chart-group h4 {
    margin: 0 0 25px 0;
    color: #333;
    font-size: 18px;
    text-align: center;
    font-weight: 700;
    padding-bottom: 12px;
    border-bottom: 2px solid #e9ecef;
}

.decomp-chart-vertical-item {
    background: #fff;
    padding: 25px;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    margin-bottom: 30px;
    width: 90%; /* Делаем графики уже - 90% вместо 100% */
    max-width: 1200px; /* Ограничиваем максимальную ширину */
    margin-left: auto;
    margin-right: auto;
    position: relative;
    transition: all 0.3s ease;
}

.decomp-chart-vertical-item:hover {
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    transform: translateY(-2px);
}

.decomp-chart-vertical-item h5 {
    margin: 0 0 20px 0;
    color: #444;
    font-size: 17px;
    text-align: center;
    font-weight: 600;
    padding-bottom: 12px;
    border-bottom: 1px solid #f0f0f0;
    background: linear-gradient(to right, #f8f9fa, #ffffff, #f8f9fa);
    border-radius: 6px 6px 0 0;
}

/* Контейнер для canvas - делаем уже и выше */
.decomp-chart-vertical-item .chart-container {
    position: relative;
    width: 80%;
    min-height: 600px; /* Делаем выше */
    max-height: 600px; /* Увеличиваем максимальную высоту */
    margin-bottom: 20px;
    padding: 15px;
    background: #fafafa;
    border-radius: 8px;
    border: 1px solid #eee;
}

.decomp-chart-vertical-item canvas {
    min-height: 400px !important; /* Увеличиваем минимальную высоту */
    max-height: 500px !important; /* Увеличиваем максимальную высоту */
    width: 75% !important; /* Делаем уже - 95% вместо 100% */
    margin: 0 auto 15px auto !important;
    display: block !important;
}

/* Статистика под графиками - делаем компактнее */
.decomp-chart-vertical-item .diagonal-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 20px;
    padding: 18px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 8px;
    border: 1px solid #dee2e6;
    font-size: 13px;
    justify-content: center;
    align-items: center;
    width: 90%; /* Сужаем статистику тоже */
    margin-left: auto;
    margin-right: auto;
}

.decomp-chart-vertical-item .stat-label {
    color: #495057;
    font-weight: 600;
    margin-right: 6px;
    font-size: 12.5px;
    white-space: nowrap;
}

.decomp-chart-vertical-item .stat-value {
    color: #007bff;
    font-weight: 700;
    margin-right: 15px;
    padding: 6px 10px;
    border-radius: 5px;
    background: white;
    border: 1px solid #dee2e6;
    min-width: 60px;
    text-align: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.2s ease;
}

.decomp-chart-vertical-item .stat-value:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

/* Адаптивность для мобильных устройств */
@media (max-width: 768px) {
    .decomp-chart-vertical-item {
        width: 95%; /* На мобильных делаем шире */
        padding: 20px;
    }
    
    .decomp-chart-vertical-item canvas {
        width: 100% !important; /* На мобильных - полная ширина */
        min-height: 350px !important;
    }
    
    .decomp-chart-vertical-item .diagonal-stats {
        width: 100%;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
    }
    
    .decomp-chart-vertical-item .stat-value {
        margin-right: 0;
        margin-bottom: 5px;
    }
}

/* Улучшаем визуализацию заголовков групп */
.decomp-chart-group:first-child {
    margin-top: 10px;
}

.decomp-chart-group:last-child {
    margin-bottom: 20px;
}

/* Стили для поля ввода вероятности */
.probability-input {
    transition: all 0.3s ease;
}

.probability-input:focus {
    box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.2);
    border-color: #ff9800;
}

.probability-input.saving {
    background-color: #e8f5e9;
    border-color: #4caf50;
}

.probability-input.error {
    background-color: #ffebee;
    border-color: #f44336;
}

.prob-input-wrapper {
    position: relative;
}

.prob-input-wrapper .saving-indicator {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 16px;
    height: 16px;
    background-color: #4caf50;
    border-radius: 50%;
    display: none;
}

.prob-input-wrapper.saving .saving-indicator {
    display: block;
    animation: pulse 0.5s;
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.7; }
    100% { transform: scale(1); opacity: 1; }
}

table td:last-child {
    text-align: center;
}

/* Стили для шторок (аккордеона) в стиле iOS Liquid Glass */
.hp-accordion {
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 16px;
    margin-bottom: 20px;
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.8) 0%,
        rgba(255, 255, 255, 0.6) 100%
    );
    overflow: hidden;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: 
        0 4px 30px rgba(0, 0, 0, 0.08),
        0 1px 0 rgba(255, 255, 255, 0.5) inset,
        0 -1px 0 rgba(0, 0, 0, 0.05) inset;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
}

.hp-accordion::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.05) 100%
    );
    border-radius: 16px;
    z-index: -1;
}

.hp-accordion-header {
    padding: 20px 24px;
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.9) 0%,
        rgba(255, 255, 255, 0.7) 100%
    );
    cursor: pointer;
    font-weight: 600;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-bottom: 1px solid transparent;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
}

.hp-accordion-header::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.4),
        transparent
    );
    transition: left 0.6s ease;
}

.hp-accordion-header:hover {
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.95) 0%,
        rgba(255, 255, 255, 0.8) 100%
    );
}

.hp-accordion-header:hover::before {
    left: 100%;
}

.hp-accordion-header:hover .hp-accordion-title {
    color: var(--primary);
    transform: translateX(4px);
}

.hp-accordion-header:hover .hp-accordion-icon {
    color: var(--primary);
    transform: scale(1.1);
}

.hp-accordion-title {
    font-size: 17px;
    color: rgba(51, 51, 51, 0.95);
    font-weight: 600;
    letter-spacing: -0.01em;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 12px;
    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}

.hp-accordion-title::before {
    content: '';
    width: 4px;
    height: 20px;
    background: linear-gradient(
        to bottom,
        rgba(0, 123, 255, 0.8),
        rgba(0, 123, 255, 0.4)
    );
    border-radius: 2px;
    transition: all 0.3s ease;
}

.hp-accordion-icon {
    font-size: 14px;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    color: rgba(119, 119, 119, 0.9);
    background: rgba(255, 255, 255, 0.8);
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.5);
    box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.05),
        0 1px 0 rgba(255, 255, 255, 0.8) inset;
}

.hp-accordion-body {
    max-height: 0;
    overflow: hidden;
    padding: 0 24px;
    background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.4),
        rgba(255, 255, 255, 0.2)
    );
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0;
    transform: translateY(-10px);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
}

/* Активное состояние (открыто) */
.hp-accordion.active {
    box-shadow: 
        0 8px 40px rgba(0, 0, 0, 0.12),
        0 2px 0 rgba(255, 255, 255, 0.6) inset,
        0 -2px 0 rgba(0, 0, 0, 0.05) inset;
    transform: translateY(-2px);
    border-color: rgba(255, 255, 255, 0.5);
}

.hp-accordion.active .hp-accordion-header {
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.95) 0%,
        rgba(255, 255, 255, 0.85) 100%
    );
    border-bottom: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 
        0 2px 4px rgba(0, 0, 0, 0.05),
        0 1px 0 rgba(255, 255, 255, 0.8) inset;
}

.hp-accordion.active .hp-accordion-title {
    color: rgba(0, 123, 255, 0.95);
    font-weight: 700;
}

.hp-accordion.active .hp-accordion-title::before {
    background: linear-gradient(
        to bottom,
        rgba(0, 123, 255, 1),
        rgba(0, 123, 255, 0.6)
    );
    box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
}

.hp-accordion.active .hp-accordion-icon {
    color: var(--primary);
    transform: rotate(180deg) scale(1.1);
    background: rgba(255, 255, 255, 0.9);
    border-color: rgba(0, 123, 255, 0.2);
    box-shadow: 
        0 2px 10px rgba(0, 123, 255, 0.15),
        0 1px 0 rgba(255, 255, 255, 0.9) inset;
}

.hp-accordion.active .hp-accordion-body {
    max-height: 50000px;
    padding: 24px;
    opacity: 1;
    transform: translateY(0);
}

/* Эффект для содержимого внутри аккордеона */
.hp-accordion-body > * {
    opacity: 0;
    transform: translateY(10px);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.1s;
}

.hp-accordion.active .hp-accordion-body > * {
    opacity: 1;
    transform: translateY(0);
}

/* Эффект для вложенных контейнеров внутри аккордеона */
.hp-accordion .hp-table-wrapper,
.hp-accordion .decomp-chart-group,
.hp-accordion .decomp-chart-vertical-item {
    background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.7) 0%,
        rgba(255, 255, 255, 0.5) 100%
    ) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
    border-radius: 12px !important;
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.06),
        0 1px 0 rgba(255, 255, 255, 0.6) inset !important;
}

/* Плавная анимация для графиков внутри аккордеона */
.hp-accordion canvas {
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.2s;
    opacity: 0;
    transform: scale(0.95);
}

.hp-accordion.active canvas {
    opacity: 1;
    transform: scale(1);
}

/* Эффект для таблиц внутри аккордеона */
.hp-accordion table {
    background: rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(5px);
    border-radius: 8px;
    overflow: hidden;
}

.hp-accordion table th {
    background: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.9),
        rgba(255, 255, 255, 0.7)
    );
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.5);
}

.hp-accordion table tr:hover td {
    background: rgba(255, 255, 255, 0.4);
}

/* Эффект для заголовков внутри аккордеона */
.hp-accordion-body h3,
.hp-accordion-body h4 {
    color: rgba(51, 51, 51, 0.9);
    font-weight: 600;
    text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
    position: relative;
    padding-left: 16px;
}

.hp-accordion-body h3::before,
.hp-accordion-body h4::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 4px;
    height: 60%;
    background: linear-gradient(
        to bottom,
        rgba(0, 123, 255, 0.6),
        rgba(0, 123, 255, 0.3)
    );
    border-radius: 2px;
}

/* Эффект для разделителей */
.hp-accordion-body hr {
    border: none;
    height: 1px;
    background: linear-gradient(
        to right,
        transparent,
        rgba(255, 255, 255, 0.6),
        transparent
    );
    margin: 24px 0;
}


/* Центрируем все заголовки и ячейки, кроме первой колонки */
#table-participant-load th:not(:first-child),
#table-participant-load td:not(:first-child),
#table-participant-capacity-load th:not(:first-child),
#table-participant-capacity-load td:not(:first-child) {
    text-align: center;
}


/* Общий стеклянный эффект для контейнеров */
.hp-table-wrapper, 
.decomp-chart-vertical-item,
.decomp-chart-group {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
}

/* Эффект для аккордеона */
.hp-accordion {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.6) 100%);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* Эффект для полей ввода */
.hp-input {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(5px);
    border: 1px solid rgba(0, 123, 255, 0.2);
    transition: all 0.3s ease;
}

.hp-input:focus {
    background: rgba(255, 255, 255, 0.95);
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1), 0 4px 15px rgba(0, 123, 255, 0.1);
}

/* Стеклянный эффект для контейнеров графиков */
.decomp-chart-vertical-item .chart-container,
.decomp-chart-vertical-item,
.hp-table-wrapper {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.85) 0%, 
        rgba(255, 255, 255, 0.65) 100%) !important;
    backdrop-filter: blur(12px) !important;
    -webkit-backdrop-filter: blur(12px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    box-shadow: 
        0 8px 32px rgba(31, 38, 135, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.6) !important;
}

/* Специально для контейнеров графиков внутри аккордеонов */
.hp-accordion-body > div > div {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.9) 0%, 
        rgba(255, 255, 255, 0.7) 100%) !important;
    backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.25) !important;
    box-shadow: 
        0 4px 20px rgba(31, 38, 135, 0.08),
        inset 0 1px 1px rgba(255, 255, 255, 0.8) !important;
}

/* Эффект перелива для заголовков графиков */
.decomp-chart-group h4,
.decomp-chart-vertical-item h5 {
    background: linear-gradient(90deg, 
        rgba(255, 255, 255, 0.9) 0%, 
        rgba(255, 255, 255, 0.7) 50%, 
        rgba(255, 255, 255, 0.9) 100%) !important;
    backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    color: rgba(51, 51, 51, 0.9) !important;
}

/* Исправление для выпадающих списков только в определенных модальных окнах */
.hp-modal.hp-modal-with-dropdown {
    position: relative;
    overflow: visible !important;
}

.hp-modal.hp-modal-with-dropdown .hp-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    max-height: 250px;
    overflow-y: auto;
    background: white;
    border: 1px solid var(--border);
    border-radius: 0 0 var(--radius) var(--radius);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    z-index: 100001;
    display: none;
    margin-top: 0;
    border-top: none;
}

.hp-modal.hp-modal-with-dropdown .hp-dropdown-item {
    padding: 10px 12px;
    cursor: pointer;
    font-size: 13px;
    border-bottom: 1px solid #f1f1f1;
    transition: background 0.2s;
}

.hp-modal.hp-modal-with-dropdown .hp-dropdown-item:hover {
    background: #f8f9fa;
    color: var(--primary);
}

.hp-modal.hp-modal-with-dropdown .hp-dropdown-item:last-child {
    border-bottom: none;
}

/* --- Стили для счетчика ресурсов и всплывающего окна (тултипа) --- */

/* Контейнер: держит кнопку и счетчик вместе */
.resource-cell-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative; /* Важно: тултип будет позиционироваться относительно этого блока */
    width: max-content;
}

/* Счетчик (цифра) */
.resource-count-badge {
    min-width: 24px;
    height: 24px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 700;
    cursor: help;
    transition: all 0.2s ease;
    
    /* Стиль для активного состояния (есть ресурсы) */
    background: rgba(0, 123, 255, 0.1);
    color: var(--primary);
    border: 1px solid rgba(0, 123, 255, 0.2);
}

/* Стиль для пустого состояния (0 ресурсов) */
.resource-count-badge.empty {
    background: rgba(0, 0, 0, 0.05);
    color: #999;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

/* Эффект при наведении на весь блок */
.resource-cell-wrapper:hover .resource-count-badge {
    transform: scale(1.1);
}
.resource-cell-wrapper:hover .resource-count-badge:not(.empty) {
    background: var(--primary);
    color: white;
}

/* Всплывающее окно (Тултип) */
.resource-tooltip {
    visibility: hidden;
    opacity: 0;
    position: absolute;
    bottom: 100%; /* Появляется СВЕРХУ от элемента */
    left: 50%;
    transform: translateX(-50%) translateY(10px); /* Начальная позиция для анимации */
    
    /* Стеклянный стиль */
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
    
    padding: 15px;
    border-radius: 12px;
    width: max-content;
    max-width: 300px; /* Ограничиваем ширину, чтобы не было слишком широко */
    z-index: 1000;
    text-align: center;
    pointer-events: none; /* Чтобы мышка не "застревала" в тултипе */
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Стрелочка снизу тултипа */
.resource-tooltip::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -6px;
    border-width: 6px;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.95) transparent transparent transparent;
}

/* Показываем тултип при наведении */
.resource-cell-wrapper:hover .resource-tooltip {
    visibility: visible;
    opacity: 1;
    transform: translateX(-50%) translateY(-10px); /* Поднимаем чуть выше */
}

/* Текст внутри тултипа, когда пусто */
.tooltip-empty-text {
    font-size: 12px;
    color: #777;
    font-style: italic;
    line-height: 1.4;
}

/* Заголовок внутри тултипа */
.tooltip-header {
    font-size: 11px;
    text-transform: uppercase;
    color: #999;
    font-weight: 700;
    margin-bottom: 8px;
    border-bottom: 1px solid #eee;
    padding-bottom: 4px;
}

/* --- НОВЫЕ СТИЛИ ДЛЯ ВЫДЕЛЕНИЯ И ПАНЕЛИ ДЕЙСТВИЙ --- */

/* Стиль выделенного элемента */
.selectable-item {
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid transparent; /* Резервируем место под рамку */
}

/* Эффект при наведении (подсказывает, что можно кликнуть) */
.selectable-item:hover {
    filter: brightness(0.98);
}

/* Активное выделение (Step) */
.step-item.selected {
    border-color: var(--primary) !important;
    background-color: rgba(0, 123, 255, 0.05) !important;
    box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.15) !important;
    transform: scale(1.01);
}

/* Активное выделение (Group) */
.group-container.selected {
    border-color: var(--primary) !important;
    box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.15), 0 8px 32px rgba(31, 38, 135, 0.1) !important;
    position: relative;
    z-index: 10; /* Чтобы выделенная группа была выше */
}

/* Плавающая панель действий (Bottom Right) */
#floating-action-panel {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 320px;
    max-width: 90vw;
    background: #ffffff;
    border-radius: 16px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(0,0,0,0.05);
    padding: 20px;
    z-index: 999999 !important;
    display: none; 
    flex-direction: column;
    border: 1px solid #e0e0e0;
    font-family: inherit;
    box-sizing: border-box;
}

#floating-action-panel.visible {
    display: flex !important;
    animation: slideInUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}

@keyframes slideInUp {
    from { transform: translateY(100px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

#floating-action-panel h4 {
    margin: 0 0 8px 0;
    font-size: 14px;
    color: #333;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
    font-weight: 600;
    text-align: left; /* Заголовок оставим слева */
}

#fap-description {
    font-size: 13px;
    color: #666;
    background: #f8f9fa;
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 12px;
    line-height: 1.4;
    text-align: center; /* Текст подсказки по центру */
}

/* Контейнер кнопок */
.panel-actions-row {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
}

/* Стили кнопок с принудительным центрированием */
.panel-actions-row button {
    width: 100%;
    margin: 0;
    padding: 12px 15px;      /* Увеличили область клика */
    white-space: normal;
    
    /* Центрирование текста любой сложности */
    display: flex;           
    align-items: center;     /* Центр по вертикали */
    justify-content: center; /* Центр по горизонтали */
    text-align: center;      /* Резервное центрирование */
    
    box-sizing: border-box;
    font-weight: 600;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    transition: transform 0.1s;
}

.panel-actions-row button:active {
    transform: scale(0.98); /* Эффект нажатия */
}

/* Обновляем Drag Handle (Ручку перетаскивания) */
/* Убираем старый стиль, делаем его более компактным и встроенным */
.drag-handle-integrated {
    cursor: grab;
    color: #999;
    padding: 0 8px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s;
    user-select: none;
}

.drag-handle-integrated:hover {
    color: var(--text);
}

.drag-handle-integrated:active {
    cursor: grabbing;
}

/* Исправление заголовка группы для включения Drag Handle */
.group-header {
    /* Изменяем padding чтобы вместить иконку руки */
    padding: 4px 8px 4px 4px !important; 
    gap: 5px !important;
}

/* Скрываем старые внешние ручки, если они остались */
.item-wrapper > .drag-handle {
    display: none !important; 
}

#fap-description {
    font-size: 13px;
    color: #666;
    line-height: 1.4;
    margin-bottom: 12px;
    padding: 8px;
    background: rgba(0,0,0,0.03);
    border-radius: 8px;
}

#fap-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

#floating-action-panel {
    /* Добавим немного ширины для информативности */
    max-width: 320px;
}

.step-item, .group-container {
    user-select: none; /* Предотвращает выделение текста при перетаскивании */
}

.step-item:hover, .group-container:hover {
    cursor: grab;
}

.step-item:active, .group-container:active {
    cursor: grabbing;
}

/* Для интерактивных элементов внутри этапов/групп сохраняем стандартный курсор */
.step-item input:hover, 
.step-item button:hover,
.group-container input:hover,
.group-container button:hover {
    cursor: default;
}

.hp-logo-link {
    display: flex;
    align-items: center;
    padding: 0 15px;
    text-decoration: none;
    transition: opacity 0.2s;
}

.hp-logo-link:hover {
    opacity: 0.8;
}

.hp-logo-link img {
    height: 40px; /* Регулируй высоту под свой дизайн */
    width: auto;
    display: block;
}

/* Опционально: если на мобилках места мало, можно чуть сжать отступы у вкладок */
@media (max-width: 768px) {
    .hp-tab {
        padding: 10px 8px;
        font-size: 13px;
    }
    .hp-logo-link {
        padding: 0 8px;
    }
}

    </style>

</head>
 <body><div id="Mentor-app">
     
     <div class="hp-tabs">
         
    <div class="hp-tab active" onclick='app.switchTab("tab-participants")'>Участники</div>
    <div class="hp-tab" onclick='app.switchTab("tab-resources")'>Ресурсы</div>
    <div class="hp-tab" onclick='app.switchTab("tab-steps")'>Этапы</div>
    <div class="hp-tab" onclick='app.switchTab("tab-groups")'>Настройка процесса</div>
    <div class="hp-tab" onclick='app.switchTab("tab-results")'>Результаты</div>
    
    <div class="hp-tabs-actions">
        <button class="hp-btn hp-btn-warning hp-btn-sm" onclick="app.exportProject()">Экспорт JSON</button>
        <button class="hp-btn hp-btn-sm" onclick="app.triggerImport()">Импорт JSON</button>
        <input type="file" id="import-file-input" accept=".json,application/json" style="display:none" onchange="app.importProject(this)">
    </div>
</div>
 
 <div id="tab-participants" class="hp-content active">
    <div class="hp-controls-row">
    <div class="hp-form-group" style="flex:2">
        <label>Имя участника</label>
        <input type="text" id="part-name" class="hp-input" placeholder="Например: Менеджер">
    </div>
    <div class="hp-form-group" style="flex:1">
        <label>Ставка (₽/час)</label>
        <input type="number" id="part-rate" class="hp-input" placeholder="1000">
    </div>
    <div class="time-input-group" style="flex:1">
        <div class="hp-form-group">
            <label>Ресурс (ч)</label>
            <input type="number" id="part-cap-h" class="hp-input" placeholder="0" min="0">
        </div>
        <div class="hp-form-group">
            <label>(мин)</label>
            <input type="number" id="part-cap-m" class="hp-input" placeholder="0" min="0" max="59">
        </div>
    </div>
    <div class="hp-form-group" style="flex:0.5; align-items: center;">
        <label title="Не показывать в графиках">Скрыть</label>
        <input type="checkbox" id="part-exclude" style="width: 20px; height: 20px; margin-top: 5px; cursor: pointer;">
    </div>
    <button class="hp-btn hp-btn-success" onclick="app.addParticipant()">Добавить</button>
</div>

    <div class="hp-table-wrapper">
        <table id="table-part">
    <thead>
        <tr>
            <th>Имя</th>
            <th>Ставка (₽/час)</th>
            <th>Доступный ресурс</th>
            <th>Скрыть</th> 
            <th>Действия</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>
    </div>
</div>
 
 <div id="tab-resources" class="hp-content"><div class="hp-controls-row"><div class="hp-form-group" style="flex:2"><label>Название ресурса</label><input type="text" id="res-name" class="hp-input" placeholder="Например: Договор"></div><button class="hp-btn hp-btn-success" onclick="app.addResource()">Добавить</button></div><div class="hp-table-wrapper">
     
     <table id="table-resources">
    <thead>
        <tr>
            <th>Название</th>
            <th>Тип</th>
            <th>Стоимость (₽)</th> <!-- Добавляем новый столбец -->
            <th>Компоненты</th>
            <th>Источник</th>
            <th>Действия</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>
     
     
     </div></div><div id="tab-steps" class="hp-content"><div class="hp-controls-row"><button class="hp-btn hp-btn-success" onclick="app.openStepCreationModal()">Добавить Этап</button></div><div class="hp-table-wrapper"><table id="table-steps"><thead><tr><th>ID</th><th>Действие</th><th>Ответственный</th><th>Время</th><th>Входы</th><th>Выходы</th><th>Действия</th></tr></thead><tbody></tbody></table></div></div>
     
     <!-- ИСПРАВЛЕННЫЙ HTML (убрать дубликаты) -->
<div id="tab-groups" class="hp-content">
    <h2>Структура процесса</h2>
    
    <div id="steps-container"></div> <!-- ОСТАВИТЬ ТОЛЬКО ОДИН -->
    
    <div id="floating-action-panel">
        <h4 id="fap-title">Выбрано элементов: 0</h4>
        <div id="fap-description" style="font-size: 12px; color: #777; margin-bottom: 10px;"></div>
        <div class="panel-actions-row" id="fap-buttons"></div>
        <button class="hp-btn hp-btn-sm hp-btn-danger" style="margin-top:5px; width:100%" onclick="app.clearSelection()">Снять выделение</button>
    </div>
</div>
     
     
     
     
     
     
     
     
     
     <div id="tab-results" class="hp-content">
    <div class="hp-controls-row">
        <a href="http://projectmentor.ru/menu-pro"></a>
        <button class="hp-btn hp-btn-success" onclick="app.calculateResults()">Рассчитать</button>
        <input type="file" id="import-file-input" accept=".json,application/json" style="display:none" onchange="app.importProject(this)">
    </div>

<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:20px;margin-bottom:30px">
    <!-- Стоимость минимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(40, 167, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(40, 167, 69, 0.95),
                rgba(40, 167, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Стоимость (минимальная)</div>
        <div id="res-cost-min" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ₽</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(40, 167, 69, 0.9),
                    rgba(40, 167, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(40, 167, 69, 0.3);
            "></span>
            Оптимальный сценарий
        </p>
    </div>

    <!-- Стоимость средняя -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(254, 254, 0, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(254, 254, 0, 0.95),
                rgba(255, 220, 0, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Стоимость (прогнозируемая)</div>
        <div id="res-cost" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ₽</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(254, 254, 0, 0.9),
                    rgba(255, 220, 0, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(254, 254, 0, 0.3);
            "></span>
            Прогнозируемый сценарий
        </p>
    </div>

    <!-- Стоимость максимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(220, 53, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(220, 53, 69, 0.95),
                rgba(220, 53, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Стоимость (максимальная)</div>
        <div id="res-cost-max" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ₽</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(220, 53, 69, 0.9),
                    rgba(220, 53, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(220, 53, 69, 0.3);
            "></span>
            Наихудший сценарий
        </p>
    </div>

    <!-- Время минимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(40, 167, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(40, 167, 69, 0.95),
                rgba(40, 167, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Время (минимальное)</div>
        <div id="res-time-min" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ч.</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(40, 167, 69, 0.9),
                    rgba(40, 167, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(40, 167, 69, 0.3);
            "></span>
            Минимальное время
        </p>
    </div>

    <!-- Время среднее -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(254, 254, 0, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(254, 254, 0, 0.95),
                rgba(255, 220, 0, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Время (прогнозируемое)</div>
        <div id="res-time" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ₽</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(254, 254, 0, 0.9),
                    rgba(255, 220, 0, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(254, 254, 0, 0.3);
            "></span>
            Прогнозируемый сценарий
        </p>
    </div>

    <!-- Время максимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(220, 53, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(220, 53, 69, 0.95),
                rgba(220, 53, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Время (максимальное)</div>
        <div id="res-time-max" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ч.</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(220, 53, 69, 0.9),
                    rgba(220, 53, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(220, 53, 69, 0.3);
            "></span>
            Максимальное время
        </p>
    </div>

    <!-- Человеко-часы минимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(40, 167, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(40, 167, 69, 0.95),
                rgba(40, 167, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Человеко-часы (минимальные)</div>
        <div id="res-manhours-min" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ч-ч</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(40, 167, 69, 0.9),
                    rgba(40, 167, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(40, 167, 69, 0.3);
            "></span>
            Оптимальный сценарий
        </p>
    </div>

    <!-- Человеко-часы средние -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(254, 254, 0, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(254, 254, 0, 0.95),
                rgba(255, 220, 0, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Человеко-часы (прогнозируемые)</div>
        <div id="res-manhours-avg" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ₽</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(254, 254, 0, 0.9),
                    rgba(255, 220, 0, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(254, 254, 0, 0.3);
            "></span>
            Прогнозируемый сценарий
        </p>
    </div>

    <!-- Человеко-часы максимум -->
    <div style="
        background: linear-gradient(135deg, 
            rgba(255, 255, 255, 0.85) 0%, 
            rgba(255, 255, 255, 0.65) 100%);
        padding: 24px;
        border-radius: 18px;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.35);
        box-shadow: 
            0 8px 32px rgba(220, 53, 69, 0.1),
            0 4px 12px rgba(0, 0, 0, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.6),
            inset 0 -1px 0 rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    ">
        <div style="
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(220, 53, 69, 0.95),
                rgba(220, 53, 69, 0.6)
            );
            border-radius: 18px 0 0 18px;
        "></div>
        <div style="
            font-size: 11px;
            color: rgba(136, 136, 136, 0.9);
            font-weight: 700;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        ">Человеко-часы (максимальные)</div>
        <div id="res-manhours-max" style="
            font-size: 38px;
            font-weight: 800;
            color: rgba(51, 51, 51, 0.95);
            margin: 12px 0;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            letter-spacing: -0.5px;
        ">0 ч-ч</div>
        <p style="
            font-size: 12px;
            color: rgba(102, 102, 102, 0.85);
            margin-top: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        ">
            <span style="
                display: inline-block;
                width: 8px;
                height: 8px;
                background: linear-gradient(
                    135deg,
                    rgba(220, 53, 69, 0.9),
                    rgba(220, 53, 69, 0.6)
                );
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(220, 53, 69, 0.3);
            "></span>
            Наихудший сценарий
        </p>
    </div>
</div>

    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">📊 Топ этапов по стоимости и времени</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Топ самых дорогих этапов</h4>
                    <canvas id="chart-top-cost-steps"></canvas>
                </div>
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Топ самых длительных этапов</h4>
                    <canvas id="chart-top-time-steps"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">👥 Графики по участникам</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:20px;">
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Время участников</h4>
                    <canvas id="chart-part-time"></canvas>
                </div>
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Стоимость участников</h4>
                    <canvas id="chart-part-cost"></canvas>
                </div>
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Человеко-часы</h4>
                    <canvas id="chart-part-manhours"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">📋 Трудозатраты и нагрузка на участников</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <h3>Трудозатраты на участников</h3>
            <div class="hp-table-wrapper" style="margin-bottom:30px">
                <table id="table-load"><thead><tr><th>Участник</th><th>Время (мин)</th><th>Время (прогн.)</th><th>Время (макс)</th><th>Стоимость (мин)</th><th>Стоимость (прогн.)</th><th>Стоимость (макс)</th><th>Ч-ч (мин)</th><th>Ч-ч (прогн.)</th><th>Ч-ч (макс)</th></tr></thead><tbody></tbody></table>
            </div>

            <h3 style="margin-top:40px">Расчет нагрузки на участников относительно времени выполнения процесса</h3>
            <div style="margin-bottom:15px;display:none;align-items:center">
                <div style="display:flex;align-items:center;gap:5px"><input type="number" id="desired-process-hours" min="0" step="1" value="8" style="padding:5px 10px;border:1px solid #ddd;border-radius:4px;width:80px" oninput="app.calculateResults()" placeholder="Часы"><span style="font-weight:700">:</span><input type="number" id="desired-process-minutes" min="0" max="59" step="1" value="0" style="padding:5px 10px;border:1px solid #ddd;border-radius:4px;width:80px" oninput="app.calculateResults()" placeholder="Минуты"></div>
            </div>
            <div class="hp-table-wrapper">
                <table id="table-participant-load"><thead>
                <tr>
                    <th>Участник</th>
                    <th>Нагрузка (мин в.в.п.)</th>
                    <th>Нагрузка (прогн. в.в.п.)</th>
                    <th>Нагрузка (макс в.в.п.)</th>
                    <th style="width: 250px;">Влияние (ув. нагрузки) <br><small>Топ-5 активных этапов</small></th>
                    <th style="width: 250px;">Влияние (ум. нагрузки) <br><small>Топ-5 этапов ожидания</small></th>
                </tr>
                </thead><tbody></tbody></table>
            </div>

            <h3 style="margin-top:40px">Нагрузка относительно доступного времени участника</h3>
            <div class="hp-table-wrapper">
                <table id="table-participant-capacity-load">
                    <thead>
                <tr>
                    <th>Участник</th>
                    <th>Доступно</th>
                    <th>Загрузка (мин)</th>
                    <th>Загрузка (прогн.)</th>
                    <th>Загрузка (макс)</th>

                </tr>
                </thead><tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">📦 Графики ресурсов</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Время создания ресурсов</h4>
                    <canvas id="chart-res-time"></canvas>
                </div>
                <div style="background:#fff;padding:15px;border-radius:8px;border:1px solid #eee">
                    <h4 style="margin:0 0 10px 0">Стоимость ресурсов</h4>
                    <canvas id="chart-res-cost"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">💰 Стоимость создания ресурсов (Таблица)</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <div class="hp-table-wrapper">
                <table id="table-resource-costs"><thead><tr><th>Ресурс</th><th>Стоимость (мин-макс)</th><th>Время (мин-макс)</th><th>Источники</th><th>Используемые ресурсы</th><th>Кол-во использований</th></tr></thead><tbody></tbody></table>
            </div>
        </div>
    </div>

    <div class="hp-accordion">
        <div class="hp-accordion-header" onclick="app.toggleAccordion(this)">
            <span class="hp-accordion-title">📑 Декомпозиция (Таблица)</span>
            <span class="hp-accordion-icon">▼</span>
        </div>
        <div class="hp-accordion-body">
            <div class="hp-table-wrapper">
                <table id="table-decomposition">
                    <thead>
                        <tr>
                            <th rowspan="2" style="width:40px">№</th>
                            <th rowspan="2">Название этапа</th>
                            <th colspan="3" style="text-align:center; border-bottom:1px solid #ddd">Время выполнения</th>
                            <th colspan="3" style="text-align:center; border-bottom:1px solid #ddd">Стоимость</th>
                            <th colspan="3" style="text-align:center; border-bottom:1px solid #ddd">Человеко-часы</th>
                        </tr>
                        <tr>
                            <th style="font-size:12px">мин</th>
                            <th style="font-size:12px">прогн.</th>
                            <th style="font-size:12px">макс</th>
                            <th style="font-size:12px">мин</th>
                            <th style="font-size:12px">прогн.</th>
                            <th style="font-size:12px">макс</th>
                            <th style="font-size:12px">мин</th>
                            <th style="font-size:12px">прогн.</th>
                            <th style="font-size:12px">макс</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
</div>
    
    
    
    
    
    
    
    
    
    <div id="hp-toast-container"></div>
    
    
    
    
    <div id="hp-modal-container"></div></div><script>const app = (() => {
        
        
        
        // --- ЛОГИКА ВЫДЕЛЕНИЯ И ПАНЕЛИ ДЕЙСТВИЙ ---

const toggleSelection = (itemId) => {
    const id = Number(itemId);
    
    if (state.selection.includes(id)) {
        state.selection = state.selection.filter(sid => sid !== id);
    } else {
        state.selection.push(id);
    }
    
    // Перерисовываем ВСЮ структуру для обновления классов selected
    renderGroups();
    
    // Обновляем панель действий
    updateFloatingPanel();
};

const clearSelection = () => {
    // 1. Очищаем массив в памяти
    state.selection = [];
    
    // 2. Снимаем визуальные классы со ВСЕХ возможных элементов
    // Используем более широкий селектор, чтобы захватить и этапы, и группы
    const selectedElements = document.querySelectorAll('.selected, .selectable-item.selected');
    selectedElements.forEach(el => {
        el.classList.remove('selected');
    });

    // 3. Скрываем панель (удаляем класс видимости и принудительно прячем)
    const panel = document.getElementById('floating-action-panel');
    if (panel) {
        panel.classList.remove('visible');
        // Используем setTimeout, чтобы анимация скрытия успела отработать 
        // или сразу ставим none, если нужна мгновенная реакция
        panel.style.display = 'none';
    }

    // 4. Перерисовываем интерфейс
    // Важно: renderGroups должна вызываться ПОСЛЕ очистки state.selection
    renderGroups();

    // 5. Обновляем состояние панели через стандартную функцию (контрольная проверка)
    if (typeof updateFloatingPanel === 'function') {
        updateFloatingPanel();
    }

    // 6. Закрываем модалки, если они были открыты
    if (typeof closeGroupModal === 'function') {
        closeGroupModal();
    }
    
    console.log('Selection cleared successfully'); // Для отладки в консоли
};

// Функция для поиска объекта по ID (рекурсивно)
const findItemById = (id, arr = state.structure) => {
    for (let item of arr) {
        if (item.id === id) return item;
        if (item.children) {
            const found = findItemById(id, item.children);
            if (found) return found;
        }
    }
    return null;
};

const findItemInStructure = (id, list = state.structure) => {
    // Принудительно приводим к числу для надежности сравнения
    const searchId = Number(id);

    for (let item of list) {
        if (Number(item.id) === searchId) {
            return { item, parent: list };
        }
        if (item.children && item.children.length > 0) {
            const found = findItemInStructure(searchId, item.children);
            if (found) return found;
        }
    }
    return null;
};

const updateFloatingPanel = () => {
    const panel = document.getElementById('floating-action-panel');
    const title = document.getElementById('fap-title');
    const desc = document.getElementById('fap-description');
    const buttons = document.getElementById('fap-buttons');

    if (!panel || !title || !desc || !buttons) return;

    const count = state.selection.length;

    // Скрываем если ничего не выбрано
    if (count === 0) {
        panel.classList.remove('visible');
        return;
    }

    panel.classList.add('visible');
    title.textContent = `Выбрано элементов: ${count}`;

    // Пытаемся найти реальные объекты в памяти по их ID
    const selectedObjects = state.selection.map(id => {
        const found = findItemInStructure(id);
        return found ? found.item : null;
    }).filter(i => i !== null);

    // Очищаем старый контент
    desc.innerHTML = '';
    buttons.innerHTML = '';

    // Логика отображения
    if (selectedObjects.length < count) {
        // Если нашли меньше объектов, чем выбрано ID - значит поиск сломался
        desc.innerHTML = "<span style='color:red'>Ошибка: объекты не найдены в структуре.</span>";
        return;
    }

    if (count === 1) {
        desc.innerHTML = "💡 <b>Выберите еще один элемент</b>, чтобы объединить их в группу или изменить иерархию.";
    } 
    else if (count >= 2) {
        const steps = selectedObjects.filter(i => i.type === 'step');
        const groups = selectedObjects.filter(i => i.type === 'group');

        // Сценарий 1: Только этапы -> Создать группу
        if (steps.length >= 2 && groups.length === 0) {
            desc.innerHTML = `Вы можете объединить эти <b>${steps.length} этапа(ов)</b> в новую группу.`;
            buttons.innerHTML = `<button class="hp-btn hp-btn-success hp-btn-sm" onclick="app.executeAction('createGroup')">Объединить в группу</button>`;
        }
        
        // Сценарий 2: 1 этап и 1 группа -> Вложить или сделать родителем
        else if (steps.length === 1 && groups.length === 1) {
            desc.innerHTML = "Настройка связи этапа и группы:";
            buttons.innerHTML = `
                <button class="hp-btn hp-btn-primary hp-btn-sm" onclick="app.executeAction('addToGroup')">Вложить в группу</button>
                <button class="hp-btn hp-btn-warning hp-btn-sm" onclick="app.executeAction('makeParent')">Сделать родителем</button>
            `;
        }

        // Сценарий 3: Только группы -> Слияние
        else if (groups.length >= 2 && steps.length === 0) {
            desc.innerHTML = `Объединить содержимое <b>${groups.length} групп</b> в одну общую?`;
            buttons.innerHTML = `<button class="hp-btn hp-btn-warning hp-btn-sm" onclick="app.executeAction('mergeGroups')">Слить группы</button>`;
        }
        
        // Сценарий 4: Смешанный выбор или больше 2-х элементов разного типа
        else {
            desc.innerHTML = "Выбрано несколько разнотипных элементов. Попробуйте выбрать только этапы для группировки.";
        }
    }
};

const executeAction = (actionType) => {
    // 1. Получаем реальные объекты на основе ID из выделения
    const selectedItems = state.selection.map(id => findItemById(id)).filter(x => x);
    const steps = selectedItems.filter(i => i.type === 'step');
    const groups = selectedItems.filter(i => i.type === 'group');

    console.log('Выполняем действие:', actionType); // Для отладки

    // 2. Выполняем нужную логику
    if (actionType === 'createGroup') {
        createGroupFromItems(steps);
    } else if (actionType === 'addToGroup') {
        if (steps.length > 0 && groups.length > 0) {
            addItemToGroup(steps[0], groups[0]);
        }
    } else if (actionType === 'makeParent') {
        if (steps.length > 0 && groups.length > 0) {
            makeItemParentOfGroup(steps[0], groups[0]);
        }
    } else if (actionType === 'mergeGroups') {
        if (groups.length >= 2) {
            mergeGroups(groups[0], groups[1]);
        }
    } else if (actionType === 'nestGroups') {
        if (groups.length >= 2) {
            nestGroups(groups[0], groups[1]);
        }
    }
    
    // 3. ВАЖНО: Гарантированная очистка с небольшой задержкой, 
    // чтобы интерфейс успел перерисоваться перед снятием классов
    setTimeout(() => {
        clearSelection();
    }, 50);
};         
            const el = (id) => document.getElementById(id);

const state = {
    part: [],
    resources: [],
    steps: [],
    structure: [],
    selection: [],
    temp: {
        inputs: [],
        outputs: [],
        newStepInputs: [],
        newStepOutputs: [],
        newStepMinHours: 0,
        newStepMinMinutes: 0,
        newStepMaxHours: 0,
        newStepMaxMinutes: 0,
        editStepId: null,
        editStepInputs: [],
        editStepOutputs: [],
        // НОВОЕ: временное хранилище для выбранных ответственных
        newStepRespIds: []
    }
};


// Вспомогательная функция: Проверяет, является ли childId потомком parentItem
const isDescendant = (parentItem, childId) => {
    if (!parentItem.children || parentItem.children.length === 0) return false;
    for (let child of parentItem.children) {
        if (child.id === childId) return true;
        if (child.type === 'group') {
            if (isDescendant(child, childId)) return true;
        }
    }
    return false;
};

let draggedItem = null;
            let draggedFromArray = null;
            let draggedFromIndex = null;
            let chartInstances = {};
            
            
            const save = () => {
    localStorage.setItem('Mentor_data_v17', JSON.stringify(state)); // Меняем на v17
};

const findInsertionIndex = (itemIds) => {
    // Находим минимальный индекс среди выбранных элементов в структуре
    let minIndex = Infinity;
    
    const traverse = (arr, depth = 0) => {
        for (let i = 0; i < arr.length; i++) {
            const item = arr[i];
            if (itemIds.includes(item.id)) {
                if (i < minIndex) minIndex = i;
            }
            if (item.type === 'group' && item.children) {
                traverse(item.children, depth + 1);
            }
        }
    };
    
    traverse(state.structure);
    return minIndex === Infinity ? state.structure.length : minIndex;
};

const load = () => {
    // Пробуем загрузить новую версию
    let data = localStorage.getItem('Mentor_data_v17');
    
    // Если нет новой версии, пробуем загрузить старую
    if (!data) {
        data = localStorage.getItem('Mentor_data_v16');
    }
    
    if (data) {
        try {
            const loadedData = JSON.parse(data);
            
            // Обратная совместимость для ресурсов
            if (loadedData.resources && Array.isArray(loadedData.resources)) {
                loadedData.resources.forEach(r => {
                    if (r.cost === undefined) r.cost = 0; // Добавляем cost если его нет
                });
            }
            
            // ... остальной код без изменений
        } catch (e) {
            console.error('Ошибка загрузки данных:', e);
            toast('Ошибка загрузки сохраненных данных', 'error');
        }
    }
};
            
            
const toast = (message, type = 'info') => {
    const container = el('hp-toast-container');
    const toastEl = document.createElement('div');
    toastEl.className = 'hp-toast';
    toastEl.textContent = message;
    container.appendChild(toastEl);  // ← ИСПРАВЬТЕ ЗДЕСЬ
    setTimeout(() => toastEl.remove(), 3000);
};            
            
const renderGroupedChart = (canvasId, labels, minData, avgData, maxData, labelSuffix = '') => {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }
    
    // Настройка шрифта
    Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
    Chart.defaults.color = '#666';

   chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Оптимистично',
                    data: minData,
                    backgroundColor: 'rgba(40, 167, 69, 0.7)', // Полупрозрачный зеленый
                    borderColor: 'rgba(255, 255, 255, 0.8)', // Белая рамка для стеклянного эффекта
                    borderWidth: 1,
                    borderRadius: 6, // Увеличиваем скругление
                    barPercentage: 1.0,
                    categoryPercentage: 0.8,
                    // Добавляем градиент для стеклянного эффекта
                    backgroundImage: (ctx) => {
                        const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, ctx.chart.height);
                        gradient.addColorStop(0, 'rgba(40, 167, 69, 0.9)');
                        gradient.addColorStop(0.7, 'rgba(40, 167, 69, 0.6)');
                        gradient.addColorStop(1, 'rgba(40, 167, 69, 0.3)');
                        return gradient;
                    }
                },
                {
                    label: 'Прогноз',
                    data: avgData,
                    backgroundColor: 'rgba(255, 193, 7, 0.7)',
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    borderWidth: 1,
                    borderRadius: 6,
                    barPercentage: 1.0,
                    categoryPercentage: 0.8,
                    backgroundImage: (ctx) => {
                        const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, ctx.chart.height);
                        gradient.addColorStop(0, 'rgba(255, 193, 7, 0.9)');
                        gradient.addColorStop(0.7, 'rgba(255, 193, 7, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 193, 7, 0.3)');
                        return gradient;
                    }
                },
                {
                    label: 'Максимально',
                    data: maxData,
                    backgroundColor: 'rgba(220, 53, 69, 0.7)',
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    borderWidth: 1,
                    borderRadius: 6,
                    barPercentage: 1.0,
                    categoryPercentage: 0.8,
                    backgroundImage: (ctx) => {
                        const gradient = ctx.chart.ctx.createLinearGradient(0, 0, 0, ctx.chart.height);
                        gradient.addColorStop(0, 'rgba(220, 53, 69, 0.9)');
                        gradient.addColorStop(0.7, 'rgba(220, 53, 69, 0.6)');
                        gradient.addColorStop(1, 'rgba(220, 53, 69, 0.3)');
                        return gradient;
                    }
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false, // Позволит графику лучше заполнять контейнер
            layout: {
                padding: { top: 10, bottom: 10 }
            },
            scales: {
                x: {
                    grid: { 
                        display: false, // Убираем вертикальную сетку
                        drawBorder: false 
                    },
                    ticks: { font: { size: 11 } }
                },
                y: {
                    beginAtZero: true,
                    border: { display: false }, // Убираем линию оси Y
                    grid: { 
                        color: '#f0f0f0', 
                        borderDash: [5, 5] // Пунктирная сетка
                    },
                    ticks: { padding: 10 }
                }
            },
            interaction: {
                mode: 'index',
                intersect: false,
            },
            plugins: {
                legend: {
                    position: 'bottom', // Легенда снизу выглядит аккуратнее
                    labels: {
                        usePointStyle: true, // Кружочки вместо квадратов
                        padding: 20,
                        font: { size: 12, weight: 600 }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)', // Белый фон
                    titleColor: '#333',
                    bodyColor: '#666',
                    borderColor: '#e0e0e0',
                    borderWidth: 1,
                    titleFont: { size: 13, weight: 'bold' },
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            let value = context.parsed.y;
                            let label = ' ' + context.dataset.label + ': ' + value.toLocaleString() + labelSuffix;
                            if (labelSuffix === ' мин' && value !== null) {
                                const hours = (value / 60).toFixed(1);
                                label += ` (${hours} ч)`;
                            }
                            return label;
                        }
                    }
                }
            }
       
       
       
       
        }
    });
};

const renderTwoBarsChart = (canvasId, labels, minData, maxData, labelSuffix = '') => {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }
    
    Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
    Chart.defaults.color = '#666';

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Оптимистично',
                    data: minData,
                    backgroundColor: 'rgba(40, 167, 69, 0.7)',
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    borderWidth: 1,
                    borderRadius: 6,
                    barPercentage: 1.0,
                    categoryPercentage: 0.8
                },
                {
                    label: 'Максимально',
                    data: maxData,
                    backgroundColor: 'rgba(220, 53, 69, 0.7)',
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    borderWidth: 1,
                    borderRadius: 6,
                    barPercentage: 1.0,
                    categoryPercentage: 0.8
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: {
                padding: { top: 10, bottom: 10 }
            },
            scales: {
                x: {
                    grid: { 
                        display: false,
                        drawBorder: false 
                    },
                    ticks: { font: { size: 11 } }
                },
                y: {
                    beginAtZero: true,
                    border: { display: false },
                    grid: { 
                        color: '#f0f0f0', 
                        borderDash: [5, 5]
                    },
                    ticks: { padding: 10 }
                }
            },
            interaction: {
                mode: 'index',
                intersect: false,
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        padding: 20,
                        font: { size: 12, weight: 600 }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    titleColor: '#333',
                    bodyColor: '#666',
                    borderColor: '#e0e0e0',
                    borderWidth: 1,
                    titleFont: { size: 13, weight: 'bold' },
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            let value = context.parsed.y;
                            let label = ' ' + context.dataset.label + ': ' + value.toLocaleString() + labelSuffix;
                            if (labelSuffix === ' мин' && value !== null) {
                                const hours = (value / 60).toFixed(1);
                                label += ` (${hours} ч)`;
                            }
                            return label;
                        }
                    }
                }
            }
        }
    });
};

const renderHorizontalGroupedChart = (canvasId, labels, minData, avgData, maxData, labelSuffix = '') => {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }
    
    Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
    Chart.defaults.color = '#666';

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
    {
        label: 'Максимально',
        data: maxData,
        backgroundColor: 'rgba(220, 53, 69, 0.7)',
        borderColor: '#dc3545',
        borderWidth: 1,
        borderRadius: 4,
        barPercentage: 0.8,
        categoryPercentage: 0.9
    },
    {
        label: 'Прогноз',
        data: avgData,
        backgroundColor: 'rgba(255, 193, 7, 0.7)',
        borderColor: '#ffc107',
        borderWidth: 1,
        borderRadius: 4,
        barPercentage: 0.8,
        categoryPercentage: 0.9
    },
    {
        label: 'Оптимистично',
        data: minData,
        backgroundColor: 'rgba(40, 167, 69, 0.7)',
        borderColor: '#28a745',
        borderWidth: 1,
        borderRadius: 4,
        barPercentage: 0.8,
        categoryPercentage: 0.9
    }
]

        },
        options: {
            indexAxis: 'y', // Горизонтальная ориентация
            responsive: true,
            maintainAspectRatio: false,
            layout: {
    padding: { left: 10, top: 10, bottom: 10, right: 10 }
},
scales: {
    y: {
        ticks: {
            padding: 2,      // было 5
            font: { size: 11 }
        }
    }
},
            scales: {
                x: {
                    beginAtZero: true,
                    grid: { 
                        color: '#f0f0f0', 
                        borderDash: [5, 5]
                    },
                    border: { display: false },
                    ticks: { 
                        font: { size: 11 }
                    },
                    title: {
                        display: true,
                        text: labelSuffix.includes('₽') ? 'Стоимость, ₽' : 'Время, мин',
                        font: { size: 12, weight: 'bold' }
                    }
                },
                y: {
                    grid: { 
                        display: false,
                        drawBorder: false
                    },
                    ticks: { 
                        font: { size: 12 },
                        autoSkip: false,
                        maxRotation: 0,
                        padding: 5
                    }
                }
            },
            interaction: {
                mode: 'index',
                intersect: false,
            },
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        padding: 20,
                        font: { size: 12, weight: 600 }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    titleColor: '#333',
                    bodyColor: '#666',
                    borderColor: '#e0e0e0',
                    borderWidth: 1,
                    titleFont: { size: 13, weight: 'bold' },
                    padding: 12,
                    cornerRadius: 8,
                    displayColors: true,
                    callbacks: {
                        label: function(context) {
                            let value = context.parsed.x; // В горизонтальных графиках значение по оси X
                            let label = ' ' + context.dataset.label + ': ' + value.toLocaleString() + labelSuffix;
                            if (labelSuffix === ' мин' && value !== null) {
                                const hours = (value / 60).toFixed(1);
                                label += ` (${hours} ч)`;
                            }
                            return label;
                        }
                    }
                }
            }
        }
    });
};

const renderSingleBarChart = (canvasId, labels, data, labelSuffix = '') => {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }
    
    // Определяем цвет на основе ID графика, чтобы они отличались визуально
    const isCostChart = canvasId.includes('cost');
    const baseColor = isCostChart ? 'rgba(54, 162, 235, 0.7)' : 'rgba(255, 159, 64, 0.7)'; // Синий для денег, Оранжевый для времени
    const borderColor = isCostChart ? '#36a2eb' : '#ff9f40';

    chartInstances[canvasId] = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Значение',
                    data: data,
                    backgroundColor: baseColor,
                    borderColor: borderColor,
                    borderWidth: 1,
                    borderRadius: 4,
                    barPercentage: 0.6,
                    maxBarThickness: 50 // Чтобы при 1 столбце он не был гигантским
                }
            ]
        },
        options: {
            indexAxis: 'y', // <-- ВАЖНО: Делаем график горизонтальным (так удобнее читать длинные названия этапов)
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    titleColor: '#333',
                    bodyColor: '#666',
                    borderColor: '#e0e0e0',
                    borderWidth: 1,
                    padding: 12,
                    cornerRadius: 8,
                    callbacks: {
                        label: function(context) {
                            let value = context.parsed.x; // x, так как график горизонтальный
                            let label = value.toLocaleString() + labelSuffix;
                            if (labelSuffix === ' мин') {
                                label += ` (${(value/60).toFixed(1)} ч)`;
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    grid: { color: '#f0f0f0', borderDash: [5, 5] },
                    border: { display: false }
                },
                y: {
                    grid: { display: false, drawBorder: false },
                    ticks: { 
                        font: { size: 11 },
                        autoSkip: false // Показывать все подписи
                    }
                }
            }
        }
    });
};

const addParticipant = () => {
    const name = el('part-name').value.trim();
    const rate = parseFloat(el('part-rate').value);
    const capH = parseInt(el('part-cap-h').value) || 0;
    const capM = parseInt(el('part-cap-m').value) || 0;
    const availableTime = capH * 60 + capM;
    // НОВОЕ: Считываем чекбокс
    const excludeFromStats = el('part-exclude').checked;

    if (!name || isNaN(rate) || rate < 0) {
        toast('Заполните имя и укажите ставку', 'error');
        return;
    }
    state.part.push({
        id: Date.now(),
        name,
        rate,
        availableTime: availableTime,
        excludeFromStats: excludeFromStats // НОВОЕ: Сохраняем настройку
    });
    el('part-name').value = '';
    el('part-rate').value = '';
    el('part-cap-h').value = '';
    el('part-cap-m').value = '';
    el('part-exclude').checked = false; // НОВОЕ: Сбрасываем чекбокс
    save();
    renderAll();
    toast('Участник добавлен', 'success');
};
const delPart = (id) => {
                state.part = state.part.filter(p => p.id !== id);
                save();
                renderAll();
                toast('Участник удален', 'success');
            };
const updateParticipantValue = (id, field, value) => {
    const p = state.part.find(p => p.id === id);
    if (p) {
        if (field === 'rate') p[field] = parseFloat(value) || 0;
        else p[field] = value;
        save();
        renderAll();
        
        // ДОБАВЬТЕ ЭТОТ КОД: если активна вкладка результатов, пересчитать
        if (el('tab-results').classList.contains('active')) {
            calculateResults();
        }
    }
};            
            // Добавьте это где-то рядом с updateParticipantValue
const updateParticipantAvailableTime = (id, hoursElement, minutesElement) => {
    const p = state.part.find(p => p.id === id);
    if (p) {
        const hours = parseInt(hoursElement.value) || 0;
        const minutes = parseInt(minutesElement.value) || 0;
        p.availableTime = hours * 60 + minutes;
        save();
        renderAll();
        
        // ВАЖНО: Принудительно пересчитываем результаты
        if (el('tab-results').classList.contains('active')) {
            calculateResults();
        }
    }
};
const addResource = () => {
    const name = el('res-name').value.trim();
    if (!name) {
        toast('Заполните название ресурса', 'error');
        return;
    }
    state.resources.push({
        id: Date.now(),
        name,
        cost: 0 // Добавляем поле стоимости по умолчанию 0
    });
    el('res-name').value = '';
    save();
    renderAll();
    toast('Ресурс добавлен', 'success');
};

const delResource = (resourceName) => {
    state.steps.forEach(step => {
        if (step.inputs) {
            step.inputs = step.inputs.filter(r => r !== resourceName);
        }
        if (step.outputs) {
            step.outputs = step.outputs.filter(r => r !== resourceName);
        }
    });
    state.resources = state.resources.filter(r => r.name !== resourceName); 
    save();
    renderAll();
    toast('Ресурс удален и удален из всех шагов', 'success');
};
const updateResourceValue = (id, field, value) => {
    const r = state.resources.find(r => r.id === id);
    if (r) {
        if (field === 'cost') r[field] = parseFloat(value) || 0;
        else r[field] = value;
        save();
        renderAll();
        // Добавляем пересчет результатов если активна вкладка результатов
        if (el('tab-results').classList.contains('active')) {
            calculateResults();
        }
    }
};            
const renameResourceEverywhere = (oldName, newName) => {
    if (!newName || newName.trim() === '' || oldName === newName) return;
    state.steps.forEach(step => {
        if (step.inputs) {
            step.inputs = step.inputs.map(r => r === oldName ? newName : r);
        }
        if (step.outputs) {
            step.outputs = step.outputs.map(r => r === oldName ? newName : r);
        }
    });
    state.resources.forEach(res => {
        if (res.name === oldName) res.name = newName;
    });
    save();
    renderAll();
    toast('Ресурс переименован везде', 'success');
};

const updateResourceCost = (resourceName, cost) => {
    const resource = state.resources.find(r => r.name === resourceName);
    if (resource) {
        resource.cost = parseFloat(cost) || 0;
        save();
        // Пересчитываем результаты если активна вкладка результатов
        if (el('tab-results').classList.contains('active')) {
            calculateResults();
        }
        toast('Стоимость ресурса обновлена', 'success');
    }
};

const openStepCreationModal = () => {
    state.temp.newStepInputs = [];
    state.temp.newStepOutputs = [];
    state.temp.newStepRespIds = []; // Инициализируем пустой массив
    
    el('hp-modal-container').innerHTML = `
        <div class="hp-modal-overlay" onclick="app.closeStepCreationModal()">
            <div class="hp-modal hp-modal-with-dropdown" onclick="event.stopPropagation()" style="max-width: 700px;">
                <h3>Создать новый этап</h3>
                <div class="hp-form-group" style="margin-bottom: 15px;">
                    <label>Название действия</label>
                    <input type="text" id="new-step-action" class="hp-input" placeholder="Например: Согласование документов">
                </div>
                <div class="hp-form-group" style="margin-bottom: 15px;">
                    <label>Ответственные (можно выбрать нескольких)</label>
                    <div id="new-step-responsibles-container" style="margin-bottom: 10px; min-height: 40px;">
                        ${state.temp.newStepRespIds.map(id => {
                            const part = state.part.find(p => p.id === id);
                            return part ? `<span class="hp-tag tag-blue" style="margin-right: 5px;">${part.name} <b onclick="app.removeNewStepResponsible(${id})">✖</b></span>` : '';
                        }).join('')}
                    </div>
                    <div style="position: relative;">
                        <input type="text" id="new-step-resp-search" class="hp-input" placeholder="Поиск участника...">
                        <div id="new-step-resp-drop" class="hp-dropdown"></div>
                    </div>
                </div>
                
                <div class="time-input-group" style="margin-bottom: 15px;">
                    <div class="hp-form-group">
                        <label>Минимальное время (ч:м)</label>
                        <div style="display:flex;gap:5px">
                            <input type="number" id="new-step-hours-min" class="hp-input" placeholder="0" min="0" value="0" style="width:60px"> ч
                            <input type="number" id="new-step-minutes-min" class="hp-input" placeholder="0" min="0" max="59" value="0" style="width:60px"> м
                        </div>
                    </div>
                </div>
                <div class="time-input-group" style="margin-bottom: 15px;">
                    <div class="hp-form-group">
                        <label>Максимальное время (ч:м)</label>
                        <div style="display:flex;gap:5px">
                            <input type="number" id="new-step-hours-max" class="hp-input" placeholder="0" min="0" value="0" style="width:60px"> ч
                            <input type="number" id="new-step-minutes-max" class="hp-input" placeholder="0" min="0" max="59" value="0" style="width:60px"> м
                        </div>
                    </div>
                </div>
                
                <div class="hp-form-group" style="margin-bottom: 15px;">
                    <label>Входные ресурсы</label>
                    <div id="new-step-temp-inputs-container"></div>
                    <input type="text" id="new-step-inputs-search" class="hp-input" placeholder="Поиск ресурса...">
                    <div id="new-step-inputs-drop" class="hp-dropdown"></div>
                </div>
                <div class="hp-form-group" style="margin-bottom: 15px;">
                    <label>Выходные ресурсы</label>
                    <div id="new-step-temp-outputs-container"></div>
                    <input type="text" id="new-step-outputs-search" class="hp-input" placeholder="Создать или выбрать...">
                    <div id="new-step-outputs-drop" class="hp-dropdown"></div>
                </div>
                <div class="hp-modal-buttons">
                    <button class="hp-btn hp-btn-success" onclick="app.createNewStepFromModal()">Создать</button>
                    <button class="hp-btn hp-btn-danger" onclick="app.closeStepCreationModal()">Отмена</button>
                </div>
            </div>
        </div>
    `;
    
    setTimeout(() => {
        const overlay = document.querySelector('.hp-modal-overlay'); 
        const modal = document.querySelector('.hp-modal'); 
        if (overlay) {
            overlay.style.cssText = `
                position: fixed !important; 
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0, 0, 0, 0.5) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 20000 !important;
            `;
        }
        if (modal) {
            modal.style.cssText = `
                background-color: white !important;
                display: block !important;
                padding: 20px !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5) !important;
                position: relative !important;
                max-width: 700px !important;
                width: 90% !important;
                align-self: auto !important;
                height: auto !important;
                margin-top: 50px !important;
                margin-bottom: 50px !important;
            `;
        }
    }, 100);
    
    setupNewStepInputsSearch();
    setupNewStepOutputsSearch();
    setupNewStepResponsiblesSearch();
    renderNewStepTempTags();
    renderNewStepTempOutputTags();
};

const setupNewStepResponsiblesSearch = () => {
    const searchInput = el('new-step-resp-search');
    const dropdown = el('new-step-resp-drop');
    
    if (!searchInput || !dropdown) return;
    
    const renderMatches = (query) => {
        const q = (query || '').toLowerCase();
        const matches = state.part.filter(p => 
            !state.temp.newStepRespIds.includes(p.id) && 
            p.name.toLowerCase().includes(q)
        );
        
        dropdown.innerHTML = '';
        
        if (matches.length > 0) {
            dropdown.style.display = 'block';
            matches.forEach(p => {
                const div = document.createElement('div');
                div.className = 'hp-dropdown-item';
                div.innerHTML = `${p.name} <span style="color:#666; font-size:11px">(${p.rate} ₽/час)</span>`;
                
                // --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
                div.onclick = (e) => {
                    e.stopPropagation(); // 2. Не закрывать окно при клике
                    
                    if (!state.temp.newStepRespIds.includes(p.id)) {
                        state.temp.newStepRespIds.push(p.id);
                        renderNewStepResponsibles();
                    }
                    searchInput.value = '';
                    searchInput.blur(); // 1. Убрать фокус (сделать неактивным)
                    dropdown.style.display = 'none';
                };
                // -------------------------
                
                dropdown.appendChild(div);
            });
        } else {
            dropdown.style.display = 'none';
        }
    };
    
    searchInput.addEventListener('focus', () => renderMatches(''));
    searchInput.addEventListener('input', () => renderMatches(searchInput.value));
    searchInput.addEventListener('blur', () => setTimeout(() => {
        // Небольшая задержка, чтобы успел сработать клик
        if (!dropdown.contains(document.activeElement)) dropdown.style.display = 'none';
    }, 200));
};


const renderNewStepResponsibles = () => {
    const container = el('new-step-responsibles-container');
    if (!container) return;
    
    container.innerHTML = state.temp.newStepRespIds.map(id => {
        const part = state.part.find(p => p.id === id);
        return part ? `<span class="hp-tag tag-blue" style="margin-right: 5px;">${part.name} <b onclick="app.removeNewStepResponsible(${id})">✖</b></span>` : '';
    }).join('');
};

const removeNewStepResponsible = (id) => {
    state.temp.newStepRespIds = state.temp.newStepRespIds.filter(respId => respId !== id);
    renderNewStepResponsibles();
};
            
            
            const closeStepCreationModal = () => {
    el('hp-modal-container').innerHTML = '';
};


const positionDropdown = (inputElement, dropdownElement) => {
    if (!inputElement || !dropdownElement) return;
    
    const inputRect = inputElement.getBoundingClientRect();
    const modalRect = dropdownElement.closest('.hp-modal').getBoundingClientRect();
    
    // Позиционируем dropdown под полем ввода
    dropdownElement.style.position = 'fixed';
    dropdownElement.style.top = `${inputRect.bottom}px`;
    dropdownElement.style.left = `${inputRect.left}px`;
    dropdownElement.style.width = `${inputRect.width}px`;
    
    // Ограничиваем высоту, чтобы не выходил за пределы модального окна
    const availableHeight = modalRect.bottom - inputRect.bottom - 10;
    if (availableHeight < 200) {
        dropdownElement.style.maxHeight = `${availableHeight}px`;
    }
};

const setupNewStepInputsSearch = () => {
    const si = el('new-step-inputs-search');
    const di = el('new-step-inputs-drop');
    if (!si || !di) return;
    
    // Привязываем список к контейнеру
    si.parentNode.style.position = 'relative';
    si.parentNode.appendChild(di);

    const renderMatches = (query, showAllOnEmpty) => {
        const q = (query || '').toLowerCase();
        const allResources = getAvailableResources();
        const matches = allResources
            .filter(name => !state.temp.newStepInputs.includes(name))
            .filter(name => (showAllOnEmpty && q === '') || name.toLowerCase().includes(q));
        
        di.innerHTML = '';
        
        if (matches.length > 0) {
            matches.forEach(m => {
                const div = document.createElement('div');
                div.className = 'hp-dropdown-item';
                div.innerText = m;
                div.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Важно, чтобы не сработал клик по документу
                    if (!state.temp.newStepInputs.includes(m)) {
                        state.temp.newStepInputs.push(m);
                    }
                    renderNewStepTempTags();
                    si.value = '';
                    di.style.display = 'none';
                };
                di.appendChild(div);
            });
            di.style.display = 'block';
        } else {
            di.style.display = 'none';
        }
    };

    // Открываем при фокусе или вводе
    si.addEventListener('focus', () => renderMatches(si.value, true));
    si.addEventListener('input', () => renderMatches(si.value, false));

    // ГЛАВНОЕ: Закрытие при клике вне области
    // Мы вешаем один обработчик на весь документ
    const handleOutsideClick = (e) => {
        // Если цель клика — не наше поле и не наш список
        if (!si.contains(e.target) && !di.contains(e.target)) {
            di.style.display = 'none';
        }
    };

    // Удаляем старый слушатель перед добавлением нового (чтобы не дублировались)
    document.removeEventListener('mousedown', handleOutsideClick);
    document.addEventListener('mousedown', handleOutsideClick);
};

const setupNewStepOutputsSearch = () => {
    const si = el('new-step-outputs-search');
    const di = el('new-step-outputs-drop');
    if (!si || !di) return;
    
    // 1. Привязываем список к родителю
    si.parentNode.style.position = 'relative';
    si.parentNode.appendChild(di);

    const renderMatches = (query, showAllOnEmpty) => {
        const q = (query || '').trim();
        const qLower = q.toLowerCase();
        const allResources = getAvailableResources();
        const matches = allResources
            .filter(name => (showAllOnEmpty && q === '') || name.toLowerCase().includes(qLower))
            .filter(name => !state.temp.newStepOutputs.includes(name));
        
        di.innerHTML = '';
        
        // Блок "СОЗДАТЬ"
        if (q.length > 0) {
            const createDiv = document.createElement('div');
            createDiv.className = 'hp-dropdown-item';
            createDiv.innerHTML = `СОЗДАТЬ: <span style="font-weight:normal; color:var(--primary);">${q}</span>`;
            createDiv.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!state.temp.newStepOutputs.includes(q)) state.temp.newStepOutputs.push(q);
                renderNewStepTempOutputTags();
                si.value = '';
                di.style.display = 'none';
            };
            di.appendChild(createDiv);
        }
        
        // Блок существующих ресурсов
        matches.forEach(m => {
            const div = document.createElement('div');
            div.className = 'hp-dropdown-item';
            div.innerHTML = `ВЫБРАТЬ: <span style="font-weight:normal; color:#888;">${m}</span>`;
            div.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!state.temp.newStepOutputs.includes(m)) state.temp.newStepOutputs.push(m);
                renderNewStepTempOutputTags();
                si.value = '';
                di.style.display = 'none';
            };
            di.appendChild(div);
        });
        
        if (di.children.length > 0) {
            di.style.display = 'block';
            // positionDropdown больше не нужен!
        } else {
            di.style.display = 'none';
        }
    };
    
    si.addEventListener('focus', () => renderMatches(si.value, true));
    si.addEventListener('input', () => renderMatches(si.value, false));

    // 2. Глобальный обработчик для закрытия списка при клике вне его области
    const handleOutsideClick = (e) => {
        if (!si.contains(e.target) && !di.contains(e.target)) {
            di.style.display = 'none';
        }
    };

    // Используем mousedown, чтобы список закрывался сразу при нажатии
    document.addEventListener('mousedown', handleOutsideClick);
};

            const renderNewStepTempTags = () => {
                const container = el('new-step-temp-inputs-container');
                if (!container) return;
                container.innerHTML = state.temp.newStepInputs.map((t, i) =>
                    `<span class="hp-tag tag-blue">${t} <b onclick="app.removeNewStepTempTag(${i})">✖</b></span>`
                ).join('');
            };
            const renderNewStepTempOutputTags = () => {
                const container = el('new-step-temp-outputs-container');
                if (!container) return;
                container.innerHTML = state.temp.newStepOutputs.map((t, i) =>
                    `<span class="hp-tag tag-green">${t} <b onclick="app.removeNewStepTempOutputTag(${i})">✖</b></span>`
                ).join('');
            };
            const removeNewStepTempTag = (i) => {
                state.temp.newStepInputs.splice(i, 1);
                renderNewStepTempTags();
            };
            const removeNewStepTempOutputTag = (i) => {
                state.temp.newStepOutputs.splice(i, 1);
                renderNewStepTempOutputTags();
            };
const createNewStepFromModal = () => {
    const action = el('new-step-action').value.trim();
    const respIds = [...state.temp.newStepRespIds]; // Получаем массив ID ответственных
    
    const hoursMin = parseInt(el('new-step-hours-min').value) || 0;
    const minutesMin = parseInt(el('new-step-minutes-min').value) || 0;
    const hoursMax = parseInt(el('new-step-hours-max').value) || 0;
    const minutesMax = parseInt(el('new-step-minutes-max').value) || 0;

    const totalMinutesMin = hoursMin * 60 + minutesMin;
    const totalMinutesMax = hoursMax * 60 + minutesMax;

    if (totalMinutesMin > totalMinutesMax) {
        toast('Минимальное время не может быть больше максимального', 'error');
        return;
    }
    
    if (!action || respIds.length === 0) {
        toast('Заполните название и выберите хотя бы одного ответственного', 'error');
        return;
    }
    
    const newStep = {
        id: Date.now(),
        uiId: state.steps.length + 1,
        action,
        respIds, // Теперь это массив
        timeMin: totalMinutesMin,
        timeMax: totalMinutesMax,
        inputs: [...state.temp.newStepInputs],
        outputs: [...state.temp.newStepOutputs]
    };
    
    state.temp.newStepOutputs.forEach(resName => {
        const exists = state.resources.some(r => r.name === resName);
        if (!exists) {
            state.resources.push({
                id: Date.now() + Math.random(),
                name: resName
            });
        }
    });
    
    state.temp.newStepInputs.forEach(resName => {
        const exists = state.resources.some(r => r.name === resName);
        if (!exists) {
            state.resources.push({
                id: Date.now() + Math.random(),
                name: resName
            });
        }
    });
    
    state.steps.push(newStep);
    state.structure.push({
        id: Date.now() + Math.random(),
        type: 'step',
        stepId: newStep.id
    });
    
    save();
    renderAll();
    closeStepCreationModal();
    toast('Этап создан', 'success');
};

const getAvailableResources = () => {
                const resources = new Set();
                state.resources.forEach(r => resources.add(r.name));
                state.steps.forEach(s => {
                    (s.inputs || []).forEach(r => resources.add(r));
                    (s.outputs || []).forEach(r => resources.add(r));
                });
                return Array.from(resources);
            };
            const delStep = (id) => {
                state.steps = state.steps.filter(s => s.id !== id);
                deleteItemFromStructure(id);
                save();
                renderAll();
                toast('Этап удален', 'success');
            };
            const deleteItemFromStructure = (stepId) => {
                const deleteRecursive = (arr) => {
                    for (let i = arr.length - 1; i >= 0; i--) {
                        if (arr[i].type === 'step' && arr[i].stepId === stepId) {
                            arr.splice(i, 1);
                        } else if (arr[i].type === 'group' && arr[i].children) {
                            deleteRecursive(arr[i].children);
                        }
                    }
                };
                deleteRecursive(state.structure);
                cleanupSingleItemGroups(state.structure);
            };
const updateStepValue = (id, field, value) => {
    const s = state.steps.find(s => s.id === id);
    if (s) {
        if (field === 'respId') s[field] = parseInt(value) || 0;
        else s[field] = value;
        save();
        renderAll();
    }
};            
            
            const updateStepResponsible = (id, respId) => {
                const s = state.steps.find(s => s.id === id);
                if (s) {
                    s.respId = parseInt(respId) || 0;
                    save();
                    renderAll();
                }
            };
            
            const updateStepTimeMin = (id, hours, minutes) => {
    const s = state.steps.find(s => s.id === id);
    if (s) {
        s.timeMin = hours * 60 + minutes;
        if (s.timeMin > s.timeMax) {
            // Автоматически обновляем максимум, если минимум стал больше
            s.timeMax = s.timeMin;
        }
        save();
        renderAll();
    }
};

const updateStepTimeMax = (id, hours, minutes) => {
    const s = state.steps.find(s => s.id === id);
    if (s) {
        s.timeMax = hours * 60 + minutes;
        if (s.timeMax < s.timeMin) {
            // Автоматически обновляем минимум, если максимум стал меньше
            s.timeMin = s.timeMax;
        }
        save();
        renderAll();
    }
};
            
            
const openEditResourcesModal = (stepId, type) => {
    const step = state.steps.find(s => s.id === stepId);
    if (!step) return;
    state.temp.editStepId = stepId;
    if (type === 'inputs') {
        state.temp.editStepInputs = [...(step.inputs || [])];
    } else {
        state.temp.editStepOutputs = [...(step.outputs || [])];
    }
    const title = type === 'inputs' ? 'Редактировать входные ресурсы' : 'Редактировать выходные ресурсы';
    const containerId = type === 'inputs' ? 'edit-step-inputs-container' : 'edit-step-outputs-container';
    const searchId = type === 'inputs' ? 'edit-step-inputs-search' : 'edit-step-outputs-search';
    const dropId = type === 'inputs' ? 'edit-step-inputs-drop' : 'edit-step-outputs-drop';
    
    el('hp-modal-container').innerHTML = `
        <div class="hp-modal-overlay" onclick="app.closeEditResourcesModal()">
            <div class="hp-modal hp-modal-with-dropdown" onclick="event.stopPropagation()" style="max-width: 600px; position: relative;">
                <h3>${title}</h3>
                <p>Текущие ресурсы:</p>
                <div id="${containerId}" style="margin-bottom: 15px;"></div>
                <div class="hp-form-group" style="position: relative;">
                    <label>Добавить ресурс</label>
                    <div style="position: relative;">
                        <input type="text" id="${searchId}" class="hp-input" placeholder="${type === 'inputs' ? 'Поиск ресурса...' : 'Создать или выбрать...'}">
                        <div id="${dropId}" class="hp-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 4px; max-height: 200px; overflow-y: auto; z-index: 20001; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                    </div>
                </div>
                <div class="hp-modal-buttons">
                    <button class="hp-btn hp-btn-success" onclick="app.saveEditedResources('${type}')">Сохранить</button>
                    <button class="hp-btn hp-btn-danger" onclick="app.closeEditResourcesModal()">Отмена</button>
                </div>
            </div>
        </div>
    `;
    
    if (type === 'inputs') {
        renderEditStepInputsTags();
        setupEditStepInputsSearch();
    } else {
        renderEditStepOutputsTags();
        setupEditStepOutputsSearch();
    }
    
    // Функция для правильного позиционирования выпадающего списка
    const setupDropdownPositioning = () => {
        const searchInput = document.getElementById(searchId);
        const dropdown = document.getElementById(dropId);
        
        if (!searchInput || !dropdown) return;
        
        const adjustDropdownPosition = () => {
            if (dropdown.style.display === 'block') {
                const inputRect = searchInput.getBoundingClientRect();
                const modalRect = dropdown.closest('.hp-modal').getBoundingClientRect();
                
                // Рассчитываем доступное пространство снизу
                const spaceBelow = modalRect.bottom - inputRect.bottom - 10;
                
                if (spaceBelow >= 200) {
                    // Достаточно места снизу - показываем вниз
                    dropdown.style.top = '100%';
                    dropdown.style.bottom = 'auto';
                    dropdown.style.maxHeight = '200px';
                } else {
                    // Недостаточно места снизу - показываем вверх
                    dropdown.style.top = 'auto';
                    dropdown.style.bottom = '100%';
                    dropdown.style.maxHeight = `${inputRect.top - modalRect.top - 10}px`;
                }
                
                // Гарантируем, что dropdown не выходит за правую границу
                if (inputRect.right > modalRect.right - 10) {
                    dropdown.style.right = '0';
                    dropdown.style.left = 'auto';
                    dropdown.style.width = `${modalRect.right - inputRect.left}px`;
                } else {
                    dropdown.style.left = '0';
                    dropdown.style.right = 'auto';
                    dropdown.style.width = '100%';
                }
            }
        };
        
        // Вызываем при показе dropdown
        const originalDisplaySetter = Object.getOwnPropertyDescriptor(
            HTMLDivElement.prototype, 'style'
        ).set;
        
        Object.defineProperty(dropdown.style, 'display', {
            set: function(value) {
                originalDisplaySetter.call(this, value);
                if (value === 'block') {
                    setTimeout(adjustDropdownPosition, 10);
                }
            },
            get: function() {
                return dropdown.style.getPropertyValue('display');
            }
        });
        
        // Также корректируем при изменении размеров окна
        window.addEventListener('resize', adjustDropdownPosition);
    };
    
    setTimeout(() => {
        const overlay = document.querySelector('.hp-modal-overlay'); 
        const modal = document.querySelector('.hp-modal'); 
        if (overlay) {
            overlay.style.cssText = `
                position: fixed !important; 
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0, 0, 0, 0.5) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 20000 !important;
            `;
        }
        if (modal) {
            modal.style.cssText = `
                background-color: white !important;
                display: block !important;
                padding: 20px !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5) !important;
                position: relative !important;
                max-width: 600px !important;
                width: 90% !important;
                height: auto !important; 
                align-self: auto !important;
                max-height: 80vh;
                overflow-y: auto;
            `;
        }
        
        // Настраиваем позиционирование dropdown после создания DOM
        setupDropdownPositioning();
    }, 100);
};

const closeEditResourcesModal = () => {
                el('hp-modal-container').innerHTML = '';
                state.temp.editStepId = null;
                state.temp.editStepInputs = [];
                state.temp.editStepOutputs = [];
            };
            const renderEditStepInputsTags = () => {
                const container = el('edit-step-inputs-container');
                if (!container) return;
                container.innerHTML = state.temp.editStepInputs.map((t, i) =>
                    `<span class="hp-tag tag-blue">${t} <b onclick="app.removeEditStepInputTag(${i})">✖</b></span>`
                ).join('');
            };
            const renderEditStepOutputsTags = () => {
                const container = el('edit-step-outputs-container');
                if (!container) return;
                container.innerHTML = state.temp.editStepOutputs.map((t, i) =>
                    `<span class="hp-tag tag-green">${t} <b onclick="app.removeEditStepOutputTag(${i})">✖</b></span>`
                ).join('');
            };
            const removeEditStepInputTag = (i) => {
                state.temp.editStepInputs.splice(i, 1);
                renderEditStepInputsTags();
            };
            const removeEditStepOutputTag = (i) => {
                state.temp.editStepOutputs.splice(i, 1);
                renderEditStepOutputsTags();
            };
const setupEditStepInputsSearch = () => {
    const si = el('edit-step-inputs-search');
    const di = el('edit-step-inputs-drop');
    if (!si || !di) return;
    
    const renderMatches = (query, showAllOnEmpty) => {
        const q = (query || '').toLowerCase();
        const allResources = getAvailableResources();
        const matches = allResources
            .filter(name => !state.temp.editStepInputs.includes(name))
            .filter(name => (showAllOnEmpty && q === '') || name.toLowerCase().includes(q));
        
        di.innerHTML = '';
        if (matches.length > 0) {
            di.style.display = 'block';
            matches.forEach(m => {
                const div = document.createElement('div');
                div.className = 'hp-dropdown-item';
                div.innerText = m;
                
                div.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    if (!state.temp.editStepInputs.includes(m)) {
                        state.temp.editStepInputs.push(m);
                        renderEditStepInputsTags();
                    }
                    
                    // Закрываем dropdown и делаем поле неактивным
                    si.value = '';
                    di.style.display = 'none';
                    si.classList.add('disabled');
                    si.disabled = true;
                    
                    // Убираем фокус с поля
                    si.blur();
                    
                    // Через 300 мс возвращаем активное состояние БЕЗ фокуса
                    setTimeout(() => {
                        si.classList.remove('disabled');
                        si.disabled = false;
                        // Не ставим фокус обратно!
                    }, 300);
                };
                di.appendChild(div);
            });
        } else {
            di.style.display = 'none';
        }
    };
    
    // Стиль для неактивного состояния
    const style = document.createElement('style');
    style.textContent = `
        .hp-input.disabled {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.7;
        }
    `;
    document.head.appendChild(style);
    
    // Обработка фокуса - показываем dropdown только при явном фокусе
    si.addEventListener('focus', (e) => {
        // Не показываем dropdown если поле в disabled состоянии
        if (si.disabled) return;
        renderMatches(si.value, true);
    });
    
    // Обработка ввода
    si.addEventListener('input', () => {
        if (si.disabled) return;
        renderMatches(si.value, false);
    });
    
    // Обработка клавиши Enter
    si.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && si.value.trim()) {
            e.preventDefault();
            const newResource = si.value.trim();
            if (!state.temp.editStepInputs.includes(newResource)) {
                state.temp.editStepInputs.push(newResource);
                renderEditStepInputsTags();
            }
            
            // Делаем поле неактивным
            si.value = '';
            di.style.display = 'none';
            si.classList.add('disabled');
            si.disabled = true;
            si.blur();
            
            setTimeout(() => {
                si.classList.remove('disabled');
                si.disabled = false;
            }, 300);
        }
        
        // Закрытие dropdown по Escape
        if (e.key === 'Escape') {
            di.style.display = 'none';
            si.blur(); // Убираем фокус при Escape
        }
    });
    
    // Закрытие dropdown при клике вне
    let closeHandler;
    si.addEventListener('focus', () => {
        closeHandler = (e) => {
            if (!si.contains(e.target) && !di.contains(e.target)) {
                di.style.display = 'none';
                document.removeEventListener('click', closeHandler);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', closeHandler);
        }, 10);
    });
    
    // При потере фокуса скрываем dropdown
    si.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.activeElement !== si && !di.contains(document.activeElement)) {
                di.style.display = 'none';
            }
        }, 200);
    });
};
const setupEditStepOutputsSearch = () => {
    const si = el('edit-step-outputs-search');
    const di = el('edit-step-outputs-drop');
    if (!si || !di) return;
    
    const renderMatches = (query, showAllOnEmpty) => {
        const q = (query || '').trim();
        const qLower = q.toLowerCase();
        const allResources = getAvailableResources();
        const matches = allResources
            .filter(name => (showAllOnEmpty && q === '') || name.toLowerCase().includes(qLower))
            .filter(name => !state.temp.editStepOutputs.includes(name));
        
        di.innerHTML = '';
        
        // Вариант создания нового ресурса
        if (q.length > 0) {
            const createDiv = document.createElement('div');
            createDiv.className = 'hp-dropdown-item';
            createDiv.innerHTML = `СОЗДАТЬ: <span style="font-weight:normal; color:var(--primary);">${q}</span>`;
            
            createDiv.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if (!state.temp.editStepOutputs.includes(q)) {
                    state.temp.editStepOutputs.push(q);
                    renderEditStepOutputsTags();
                }
                
                // Закрываем dropdown и делаем поле неактивным
                si.value = '';
                di.style.display = 'none';
                si.classList.add('disabled');
                si.disabled = true;
                si.blur();
                
                setTimeout(() => {
                    si.classList.remove('disabled');
                    si.disabled = false;
                    // Не ставим фокус обратно!
                }, 300);
            };
            di.appendChild(createDiv);
        }
        
        // Существующие ресурсы
        matches.forEach(m => {
            const div = document.createElement('div');
            div.className = 'hp-dropdown-item';
            div.innerHTML = `ВЫБРАТЬ: <span style="font-weight:normal; color:#888;">${m}</span>`;
            
            div.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                
                if (!state.temp.editStepOutputs.includes(m)) {
                    state.temp.editStepOutputs.push(m);
                    renderEditStepOutputsTags();
                }
                
                // Закрываем dropdown и делаем поле неактивным
                si.value = '';
                di.style.display = 'none';
                si.classList.add('disabled');
                si.disabled = true;
                si.blur();
                
                setTimeout(() => {
                    si.classList.remove('disabled');
                    si.disabled = false;
                    // Не ставим фокус обратно!
                }, 300);
            };
            di.appendChild(div);
        });
        
        di.style.display = di.children.length > 0 ? 'block' : 'none';
    };
    
    // Стиль для неактивного состояния
    const style = document.createElement('style');
    style.textContent = `
        .hp-input.disabled {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.7;
        }
    `;
    document.head.appendChild(style);
    
    // Обработка фокуса
    si.addEventListener('focus', () => {
        if (si.disabled) return;
        renderMatches(si.value, true);
    });
    
    // Обработка ввода
    si.addEventListener('input', () => {
        if (si.disabled) return;
        renderMatches(si.value, false);
    });
    
    // Обработка клавиши Enter
    si.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && si.value.trim()) {
            e.preventDefault();
            const newResource = si.value.trim();
            if (!state.temp.editStepOutputs.includes(newResource)) {
                state.temp.editStepOutputs.push(newResource);
                renderEditStepOutputsTags();
            }
            
            // Делаем поле неактивным
            si.value = '';
            di.style.display = 'none';
            si.classList.add('disabled');
            si.disabled = true;
            si.blur();
            
            setTimeout(() => {
                si.classList.remove('disabled');
                si.disabled = false;
            }, 300);
        }
        
        // Закрытие dropdown по Escape
        if (e.key === 'Escape') {
            di.style.display = 'none';
            si.blur();
        }
    });
    
    // Закрытие dropdown при клике вне
    let closeHandler;
    si.addEventListener('focus', () => {
        closeHandler = (e) => {
            if (!si.contains(e.target) && !di.contains(e.target)) {
                di.style.display = 'none';
                document.removeEventListener('click', closeHandler);
            }
        };
        setTimeout(() => {
            document.addEventListener('click', closeHandler);
        }, 10);
    });
    
    // При потере фокуса скрываем dropdown
    si.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.activeElement !== si && !di.contains(document.activeElement)) {
                di.style.display = 'none';
            }
        }, 200);
    });
};
const saveEditedResources = (type) => {
                const step = state.steps.find(s => s.id === state.temp.editStepId);
                if (!step) return;
                if (type === 'inputs') {
                    step.inputs = [...state.temp.editStepInputs];
                } else {
                    step.outputs = [...state.temp.editStepOutputs];
                }
                save();
                renderAll();
                closeEditResourcesModal();
                toast('Ресурсы обновлены', 'success');
            };
            const cleanupSingleItemGroups = (arr) => {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i].type === 'group') {
                        if (!arr[i].children || arr[i].children.length === 0) {
                            arr.splice(i, 1);
                        } else if (arr[i].children.length === 1) {
                            arr.splice(i, 1, ...arr[i].children);
                        } else {
                            cleanupSingleItemGroups(arr[i].children);
                        }
                    }
                }
            };
const ungroupItems = (groupId) => {
    // Сразу запускаем рекурсивное разгруппирование без анимаций
    const ungroupRecursive = (arr) => {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i].id === groupId && arr[i].type === 'group') {
                arr.splice(i, 1, ...arr[i].children);
                return true;
            }
            if (arr[i].type === 'group' && arr[i].children) {
                if (ungroupRecursive(arr[i].children)) return true;
            }
        }
        return false;
    };
    
    if (ungroupRecursive(state.structure)) {
        cleanupSingleItemGroups(state.structure);
        save();
        renderGroups();
        clearSelection();
        closeGroupModal();
        toast('Группа расформирована', 'success');
    }
};

const changeGroupType = (groupId) => {
    const findAndChange = (arr) => {
        for (let item of arr) {
            if (item.id === groupId && item.type === 'group') {
                const types = ['AND', 'SEQ', 'OR'];
                let idx = types.indexOf(item.logic);
                item.logic = types[(idx + 1) % types.length];
                
                // Добавляем анимацию
                const selector = document.querySelector(`[onclick="app.changeGroupType(${groupId})"]`);
                if (selector) {
                    selector.classList.add('changing');
                    setTimeout(() => selector.classList.remove('changing'), 400);
                }
                
                // Если переключили на OR — балансируем вероятности
                if (item.logic === 'OR') {
                    rebalanceGroupProbabilities(item);
                }
                return true;
            }
            if (item.children && findAndChange(item.children)) return true;
        }
        return false;
    };
    findAndChange(state.structure);
    save();
    renderGroups();
    clearSelection();
};


const rebalanceGroupProbabilities = (group) => {
    if (group.logic !== 'OR' || !group.children || group.children.length === 0) return;

    // 1. Считаем сумму тех, кто заблокирован
    const lockedChildren = group.children.filter(c => c.isLocked);
    const lockedSum = lockedChildren.reduce((sum, c) => sum + (c.probability || 0), 0);

    // 2. Находим свободных (кто не под замком)
    const unlockedChildren = group.children.filter(c => !c.isLocked);

    if (unlockedChildren.length > 0) {
        // Вычисляем, сколько процентов осталось распределить
        // Если сумма заблокированных >= 100, то свободным достанется 0
        const remainingProb = Math.max(0, 100 - lockedSum);
        
        // Делим этот остаток поровну между всеми разблокированными
        const share = remainingProb / unlockedChildren.length;
        
        unlockedChildren.forEach(child => {
            child.probability = share;
        });
    }
    // Если все под замком, мы ничего не трогаем (сумма может стать > 100, 
    // но это выбор пользователя, раз он всё заблокировал)
};


const updateItemProbability = (itemId, value, parentId) => {
    const numValue = parseFloat(value);
    if (isNaN(numValue)) return;
    const validatedValue = Math.min(100, Math.max(0, numValue));

    const findAndUpdate = (arr) => {
        for (let item of arr) {
            if (item.id === parentId && item.type === 'group' && item.logic === 'OR') {
                const target = item.children.find(c => c.id === itemId);
                if (target) {
                    // 1. Устанавливаем новое значение
                    target.probability = validatedValue;
                    
                    // 2. Считаем, сколько заблокировано (кроме текущего)
                    const otherChildren = item.children.filter(c => c.id !== itemId);
                    const lockedSum = otherChildren
                        .filter(c => c.isLocked)
                        .reduce((sum, c) => sum + (c.probability || 0), 0);
                    
                    // 3. Доступный остаток для распределения
                    let availableForDistribution = 100 - validatedValue - lockedSum;
                    
                    // Если ушли в минус (ввели слишком много), принудительно уменьшаем вводимое
                    if (availableForDistribution < 0) {
                        target.probability = 100 - lockedSum;
                        availableForDistribution = 0;
                    }

                    const unlockedOthers = otherChildren.filter(c => !c.isLocked);
                    
                    if (unlockedOthers.length > 0) {
                        unlockedOthers.forEach(child => {
                            child.probability = availableForDistribution / unlockedOthers.length;
                        });
                    }
                    return true;
                }
            }
            if (item.children && findAndUpdate(item.children)) return true;
        }
        return false;
    };

    if (findAndUpdate(state.structure)) {
        save();
        renderGroups();
        if (typeof updateAllCharts === 'function') updateAllCharts();
    }
};

const findArrayById = (parentId) => {
                if (parentId === null) return state.structure;

                const findRecursive = (arr) => {
                    for (let item of arr) {
                        if (item.id === parentId && item.type === 'group') return item.children;
                        if (item.type === 'group' && item.children) {
                            const found = findRecursive(item.children);
                            if (found) return found;
                        }
                    }
                    return null;
                };
                return findRecursive(state.structure);
            };
const handleDragStart = (e, itemId, parentId) => {
    // 1. Блокируем перетаскивание за интерактивные элементы
    const interactiveSelectors = ['input', 'button', 'select', 'textarea', '.probability-input', '.group-type-selector', '.group-close'];
    if (interactiveSelectors.some(selector => e.target.matches(selector) || e.target.closest(selector))) {
        e.preventDefault();
        return;
    }

    // 2. ВАЖНО: Останавливаем всплытие, чтобы не сработал dragstart родительской группы
    e.stopPropagation();

    // 3. Логика перетаскивания
    draggedFromArray = findArrayById(parentId);
    if (!draggedFromArray) return;
    
    const item = draggedFromArray.find(i => i.id === itemId);
    if (!item) return;

    draggedFromIndex = draggedFromArray.findIndex(i => i.id === itemId);
    draggedItem = item;
    
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', itemId);
    
    // Визуальный эффект
    setTimeout(() => {
        const el = document.querySelector(`[data-item-id="${itemId}"]`);
        if (el) el.classList.add('dragging');
    }, 0);
};

const handleDragEnd = (e, itemId) => {
                const el = document.querySelector(`[data-item-id="${itemId}"]`);
                if (el) el.classList.remove('dragging');
                document.querySelectorAll('.drop-zone.drag-over').forEach(zone => zone.classList.remove('drag-over'));
                draggedItem = null;
                draggedFromArray = null;
                draggedFromIndex = null;
            };
            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };
            const handleDragEnter = (e) => {
                if (!draggedItem) return;
                e.currentTarget.classList.add('drag-over');
            };
            const handleDragLeave = (e) => {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    e.currentTarget.classList.remove('drag-over');
                }
            };
const handleDropOnRoot = (e, targetIndex) => {
    e.preventDefault();
    e.stopPropagation();
    if (!draggedItem || !draggedFromArray) return;
    
    // Проверка: перемещение в тот же список на то же место
    if (draggedFromArray === state.structure && (draggedFromIndex === targetIndex || draggedFromIndex === targetIndex - 1)) {
        return;
    }

    // --- ИСПРАВЛЕНИЕ: Удаляем, потом вставляем ---
    draggedFromArray.splice(draggedFromIndex, 1);
    
    // Корректируем индекс, если удаление сместило массив
    let insertIndex = targetIndex;
    if (draggedFromArray === state.structure && draggedFromIndex < targetIndex) {
        insertIndex--;
    }
    
    state.structure.splice(insertIndex, 0, draggedItem);
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    
    // Сброс
    draggedItem = null;
    draggedFromArray = null;
    draggedFromIndex = null;
};

const handleDropOnGroupChild = (e, groupId, targetIndex) => {
    e.preventDefault();
    e.stopPropagation();
    if (!draggedItem || !draggedFromArray) return;

    // 1. ЗАЩИТА: Нельзя переместить группу внутрь самой себя
    if (draggedItem.id === groupId) {
        toast('Нельзя переместить группу внутрь самой себя', 'error');
        return;
    }

    // 2. ЗАЩИТА: Нельзя переместить родителя внутрь его ребенка (проверка рекурсии)
    if (draggedItem.type === 'group' && isDescendant(draggedItem, groupId)) {
        toast('Нельзя переместить папку внутрь вложенной в неё папки', 'error');
        return;
    }

    const targetArray = findArrayById(groupId);
    if (!targetArray) return;

    // Проверка на перемещение на то же место
    if (draggedFromArray === targetArray && (draggedFromIndex === targetIndex || draggedFromIndex === targetIndex - 1)) {
        return;
    }

    // Выполняем перемещение
    draggedFromArray.splice(draggedFromIndex, 1);
    
    let insertIndex = targetIndex;
    if (draggedFromArray === targetArray && draggedFromIndex < targetIndex) {
        insertIndex--;
    }
    
    targetArray.splice(insertIndex, 0, draggedItem);
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    
    draggedItem = null;
    draggedFromArray = null;
    draggedFromIndex = null;
};

const getAllStructureItems = () => {
                const items = [];
                const collectItems = (arr) => {
                    for (let item of arr) {
                        items.push(item);
                        if (item.type === 'group' && item.children) {
                            collectItems(item.children);
                        }
                    }
                };
                collectItems(state.structure);
                return items;
            };
const openGroupModal = () => {
    const allItems = getAllStructureItems();
    
    
    
    if (allItems.length < 2) {
        toast('Необходимо минимум 2 элемента для создания групп', 'error');
        return;
    }
    el('hp-modal-container').innerHTML = `
    <div class="hp-modal-overlay" onclick="app.closeGroupModal()">
        <div class="hp-modal" onclick="event.stopPropagation()">
            <h3>Настроить группы и связи</h3>
            <p>Выберите элементы для объединения в группу:</p>
            
            <div class="checkbox-list" id="group-checkbox-list"></div>
            
            <div id="action-description"></div>
            
            <div class="hp-modal-buttons">
                <button class="hp-btn hp-btn-success" id="create-group-btn" onclick="app.handleGroupAction()">Применить</button>
                <button class="hp-btn" onclick="app.closeGroupModal()" style="background: #6c757d;">Готово</button>
                <button class="hp-btn hp-btn-danger" onclick="app.closeGroupModal()">Отмена</button>
            </div>
        </div>
    </div>
`;

    setTimeout(() => {
        const overlay = document.querySelector('.hp-modal-overlay'); 
        const modal = document.querySelector('.hp-modal'); 
        if (overlay) {
            overlay.style.cssText = `
                position: fixed !important; 
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0, 0, 0, 0.5) !important;
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 20000 !important;
            `;
        }
        if (modal) {
            modal.style.cssText = `
                background-color: white !important;
                display: block !important;
                padding: 20px !important;
                border-radius: 8px !important;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5) !important;
                position: relative !important;
                max-width: 700px !important; /* Установим максимальную ширину, если она не была задана */
                width: 90% !important;
                
                /* Исправление вытягивания по вертикали (из предыдущего обсуждения) */
                height: auto !important; 
                align-self: auto !important; 
            `;
        }
    }, 100);
    renderCheckboxList();
};

// Новая рекурсивная функция для отрисовки дерева выбора
const renderRecursiveSelection = (items) => {
    if (!items || items.length === 0) return '';

    return items.map(item => {
        let contentHtml = '';
        
        // --- ЛОГИКА ДЛЯ ЭТАПА ---
        if (item.type === 'step') {
            const step = state.steps.find(s => s.id === item.stepId);
            const badge = '<span class="checkbox-item-badge step">Этап</span>';
            const title = step ? step.action : 'Этап';
            
            let subtitleParts = [];
            
            // Форматирование времени
            if (step && step.timeMin >= 0 && step.timeMax >= 0) {
                const hMin = Math.floor(step.timeMin / 60);
                const mMin = step.timeMin % 60;
                const hMax = Math.floor(step.timeMax / 60);
                const mMax = step.timeMax % 60;
                
                const tMin = hMin > 0 ? `${hMin}ч ${mMin}м` : `${mMin}мин`;
                const tMax = hMax > 0 ? `${hMax}ч ${mMax}м` : `${mMax}мин`;
                subtitleParts.push(`${tMin} — ${tMax}`);
            }
            
            // Форматирование ответственных (поддержка множественного выбора)
            if (step && step.respIds && step.respIds.length > 0) {
                const names = step.respIds.map(rid => {
                    const p = state.part.find(x => x.id === rid);
                    return p ? p.name : '';
                }).filter(x => x).join(', ');
                if (names) subtitleParts.push(`Отв: ${names}`);
            } else if (step && step.respId) {
                // Поддержка старого формата (на всякий случай)
                const p = state.part.find(x => x.id === step.respId);
                if (p) subtitleParts.push(`Отв: ${p.name}`);
            }
            
            const subtitle = subtitleParts.join(' / ');

            return `
                <div class="checkbox-item" onclick="app.toggleCheckbox(${item.id})" style="background:white; margin-bottom:5px;">
                    <input type="checkbox" id="checkbox-${item.id}" onchange="app.updateActionDescription()" onclick="event.stopPropagation()">
                    <div class="checkbox-item-content">
                        <div class="checkbox-item-title">${title}</div>
                        <div class="checkbox-item-subtitle">${subtitle}</div>
                    </div>
                    ${badge}
                </div>
            `;
        } 
        
        // --- ЛОГИКА ДЛЯ ГРУППЫ ---
        else if (item.type === 'group') {
            const logicLabels = {
                AND: 'И (Параллельно)',
                OR: 'ИЛИ (Альтернатива)',
                SEQ: 'Последовательно'
            };
            const badgeClass = item.logic === 'AND' ? 'group-and' : (item.logic === 'OR' ? 'group-or' : 'group-seq');
            const badge = `<span class="checkbox-item-badge ${badgeClass}">Группа ${logicLabels[item.logic]}</span>`;
            const title = `Группа (${logicLabels[item.logic]})`;
            const subtitle = `${item.children.length} элементов`;

            // Определяем цвета как в основном редакторе
            let borderVar = 'var(--group-and-border)';
            let bgVar = 'var(--group-and)';
            
            if (item.logic === 'OR') {
                borderVar = 'var(--group-or-border)';
                bgVar = 'var(--group-or)';
            } else if (item.logic === 'SEQ') {
                borderVar = 'var(--group-seq-border)';
                bgVar = 'var(--group-seq)';
            }

            // Рекурсивный вызов для детей
            const childrenHtml = renderRecursiveSelection(item.children);

            return `
                <div style="border: 2px dashed ${borderVar}; background: ${bgVar}; border-radius: 8px; padding: 10px; margin-bottom: 10px;">
                    <div class="checkbox-item" onclick="app.toggleCheckbox(${item.id})" style="background: rgba(255,255,255,0.7); border: 1px solid ${borderVar}; margin-bottom: 10px;">
                        <input type="checkbox" id="checkbox-${item.id}" onchange="app.updateActionDescription()" onclick="event.stopPropagation()">
                        <div class="checkbox-item-content">
                            <div class="checkbox-item-title">${title}</div>
                            <div class="checkbox-item-subtitle">${subtitle}</div>
                        </div>
                        ${badge}
                    </div>
                    
                    <div style="padding-left: 15px; border-left: 2px solid rgba(0,0,0,0.05);">
                        ${childrenHtml}
                    </div>
                </div>
            `;
        }
        return '';
    }).join('');
};


const renderCheckboxList = () => {
    const container = el('group-checkbox-list');
    if (!container) return;
    
    if (state.structure.length === 0) {
        container.innerHTML = '<div style="color:#999; text-align:center; padding:20px;">Нет доступных элементов</div>';
    } else {
        container.innerHTML = renderRecursiveSelection(state.structure);
    }
    
    // Сбрасываем описание после перерисовки
    updateActionDescription();
};            
            
            const toggleCheckbox = (itemId) => {
                const checkbox = el(`checkbox-${itemId}`);
                checkbox.checked = !checkbox.checked;
                updateActionDescription();
            };
            const updateActionDescription = () => {
                const allItems = getAllStructureItems();
                const selected = allItems.filter(item => {
                    const checkbox = el(`checkbox-${item.id}`);
                    return checkbox && checkbox.checked;
                });
                const descContainer = el('action-description');
                const btnContainer = el('create-group-btn');
                if (selected.length === 0) {
                    descContainer.innerHTML = '';
                    btnContainer.textContent = 'Создать группу';
                    btnContainer.disabled = true;
                    btnContainer.style.opacity = '0.5';
                    return;
                }
                btnContainer.disabled = false;
                btnContainer.style.opacity = '1';
                const steps = selected.filter(item => item.type === 'step');
                const groups = selected.filter(item => item.type === 'group');
                if (steps.length >= 2 && groups.length === 0) {
                    descContainer.innerHTML = `
                <div class="action-description">
                    <strong>Действие:</strong>
                    Будет создана группа из ${steps.length} этапов
                </div>
            `;
                    btnContainer.textContent = 'Создать группу';
                } else if (steps.length === 1 && groups.length === 1) {
                    descContainer.innerHTML = `
                <div class="action-description">
                    <strong>Выберите действие:</strong>
                    <div style="margin-top: 10px;">
                        <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                            <input type="radio" name="step-group-action" value="add" checked style="margin-right: 8px;">
                            Добавить этап в группу
                        </label>
                        <label style="display: block; cursor: pointer;">
                            <input type="radio" name="step-group-action" value="parent" style="margin-right: 8px;">
                            Сделать этап родителем группы
                        </label>
                    </div>
                </div>
            `;
                    btnContainer.textContent = 'Применить';
                } else if (groups.length === 2 && steps.length === 0) {
                    descContainer.innerHTML = `
                <div class="action-description">
                    <strong>Выберите действие:</strong>
                    <div style="margin-top: 10px;">
                        <label style="display: block; margin-bottom: 8px; cursor: pointer;">
                            <input type="radio" name="group-group-action" value="merge" checked style="margin-right: 8px;">
                            Объединить группы в одну
                        </label>
                        <label style="display: block; cursor: pointer;">
                            <input type="radio" name="group-group-action" value="nest" style="margin-right: 8px;">
                            Создать новую группу с этими группами
                        </label>
                    </div>
                </div>
            `;
                    btnContainer.textContent = 'Применить';
                } else {
                    descContainer.innerHTML = `
                <div class="action-description">
                    <strong>Невозможное действие</strong>
                    Выберите либо несколько этапов, либо 1 этап + 1 группу, либо 2 группы
                </div>
            `;
                    btnContainer.disabled = true;
                    btnContainer.style.opacity = '0.5';
                }
            };
const handleGroupAction = () => {
    const allItems = getAllStructureItems();
    const selected = allItems.filter(item => {
        const checkbox = el(`checkbox-${item.id}`);
        return checkbox && checkbox.checked;
    });
    const steps = selected.filter(item => item.type === 'step');
    const groups = selected.filter(item => item.type === 'group');
    
    if (steps.length >= 2 && groups.length === 0) {
        createGroupFromItems(steps);
        closeGroupModal(); // ← РАСКОММЕНТИРОВАТЬ ЭТУ СТРОКУ
    } else if (steps.length === 1 && groups.length === 1) {
        const action = document.querySelector('input[name="step-group-action"]:checked')?.value;
        if (action === 'add') addItemToGroup(steps[0], groups[0]);
        else if (action === 'parent') makeItemParentOfGroup(steps[0], groups[0]);
        closeGroupModal(); // ← РАСКОММЕНТИРОВАТЬ ЭТУ СТРОКУ
    } else if (groups.length === 2 && steps.length === 0) {
        const action = document.querySelector('input[name="group-group-action"]:checked')?.value;
        if (action === 'merge') mergeGroups(groups[0], groups[1]);
        else if (action === 'nest') nestGroups(groups[0], groups[1]);
        clearSelection();
        closeGroupModal(); // ← РАСКОММЕНТИРОВАТЬ ЭТУ СТРОКУ
    }
};

const findAndRemoveItem = (itemId, arr) => {
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].id === itemId) {
                        const item = arr[i];
                        arr.splice(i, 1);
                        return item;
                    }
                    if (arr[i].type === 'group' && arr[i].children) {
                        const found = findAndRemoveItem(itemId, arr[i].children);
                        if (found) return found;
                    }
                }
                return null;
            };
const createGroupFromItems = (items) => {
    const itemIds = items.map(s => s.id);
    
    // Находим позицию первого элемента в структуре
    let targetPosition = null;
    for (let id of itemIds) {
        const pos = findItemPosition(id);
        if (pos && (!targetPosition || pos.index < targetPosition.index)) {
            targetPosition = pos;
        }
    }
    
    if (!targetPosition) {
        targetPosition = { parent: state.structure, index: state.structure.length };
    }
    
    const itemCopies = [];
    for (let id of itemIds) {
        const item = findAndRemoveItem(id, state.structure);
        if (item) itemCopies.push(item);
    }
    
    const newGroup = {
        id: Date.now(),
        type: 'group',
        logic: 'AND', 
        children: itemCopies
    };
    
    if (newGroup.logic === 'OR') rebalanceGroupProbabilities(newGroup);
    
    // Вставляем новую группу на позицию первого элемента
    targetPosition.parent.splice(targetPosition.index, 0, newGroup);
    
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    
    // ДОБАВИТЬ ОЧИСТКУ ВЫДЕЛЕНИЯ
    clearSelection(); // ← ДОБАВИТЬ ЭТУ СТРОКУ
    closeGroupModal();
    
    toast('Группа создана', 'success');
};

const addItemToGroup = (item, group) => {
    const itemCopy = findAndRemoveItem(item.id, state.structure);
    if (!itemCopy) return;

    const findGroupAndAdd = (arr) => {
        for (let g of arr) {
            if (g.id === group.id && g.type === 'group') {
                const groupPosition = findItemPosition(group.id);
                
                itemCopy.isLocked = false;
                itemCopy.probability = 0;
                
                g.children.push(itemCopy);
                rebalanceGroupProbabilities(g);
                
                if (groupPosition && arr[groupPosition.index] !== g) {
                    arr.splice(arr.indexOf(g), 1);
                    arr.splice(groupPosition.index, 0, g);
                }
                return true;
            }
            if (g.type === 'group' && g.children) {
                if (findGroupAndAdd(g.children)) return true;
            }
        }
        return false;
    };

    if (findGroupAndAdd(state.structure)) {
        cleanupSingleItemGroups(state.structure);
        save();
        renderGroups();
        // clearSelection() убрали отсюда, он вызовется в executeAction
        toast('Элемент добавлен в группу', 'success');
    }
}; 
const makeItemParentOfGroup = (item, group) => {
    // ЗАЩИТА: Проверяем, не является ли этап уже частью этой группы (прямо или косвенно)
    if (isDescendant(group, item.id)) {
        toast('Этот этап уже находится внутри выбранной группы. Вынесите его наружу перед объединением.', 'error');
        clearSelection(); 
        return;
    }

    // Стандартная логика (без изменений)
    const itemIds = [item.id, group.id];
    let targetPosition = null;
    for (let id of itemIds) {
        const pos = findItemPosition(id);
        if (pos && (!targetPosition || pos.index < targetPosition.index)) {
            targetPosition = pos;
        }
    }
    if (!targetPosition) {
        targetPosition = { parent: state.structure, index: state.structure.length };
    }
    
    const itemCopy = findAndRemoveItem(item.id, state.structure);
    const groupCopy = findAndRemoveItem(group.id, state.structure);
    if (!itemCopy || !groupCopy) return;
    
    const newGroup = {
        id: Date.now(),
        type: 'group',
        logic: 'AND',
        children: [itemCopy, groupCopy]
    };
    
    targetPosition.parent.splice(targetPosition.index, 0, newGroup);
    
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    
    // ВАЖНО: Вызов очистки панели
    clearSelection();
    
    toast('Создана группа с элементом в роли родителя', 'success');
};

const mergeGroups = (group1, group2) => {
    const itemIds = [group1.id, group2.id];
    
    let targetPosition = null;
    for (let id of itemIds) {
        const pos = findItemPosition(id);
        if (pos && (!targetPosition || pos.index < targetPosition.index)) {
            targetPosition = pos;
        }
    }
    
    if (!targetPosition) {
        targetPosition = { parent: state.structure, index: state.structure.length };
    }
    
    const group1Copy = findAndRemoveItem(group1.id, state.structure);
    const group2Copy = findAndRemoveItem(group2.id, state.structure);
    if (!group1Copy || !group2Copy) return;

    const mergedChildren = [
        ...(group1Copy.children || []),
        ...(group2Copy.children || [])
    ];
    
    const newGroup = {
        id: Date.now(),
        type: 'group',
        logic: 'AND',
        children: mergedChildren
    };

    if (newGroup.logic === 'OR') rebalanceGroupProbabilities(newGroup);

    targetPosition.parent.splice(targetPosition.index, 0, newGroup);
    
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    // clearSelection() убрали
    toast('Группы объединены', 'success');
}; 
const nestGroups = (group1, group2) => {
    const itemIds = [group1.id, group2.id];
    
    let targetPosition = null;
    for (let id of itemIds) {
        const pos = findItemPosition(id);
        if (pos && (!targetPosition || pos.index < targetPosition.index)) {
            targetPosition = pos;
        }
    }
    
    if (!targetPosition) {
        targetPosition = { parent: state.structure, index: state.structure.length };
    }
    
    const group1Copy = findAndRemoveItem(group1.id, state.structure);
    const group2Copy = findAndRemoveItem(group2.id, state.structure);
    if (!group1Copy || !group2Copy) return;
    
    const newGroup = {
        id: Date.now(),
        type: 'group',
        logic: 'AND',
        children: [group1Copy, group2Copy]
    };
    
    targetPosition.parent.splice(targetPosition.index, 0, newGroup);
    
    cleanupSingleItemGroups(state.structure);
    save();
    renderGroups();
    // clearSelection() убрали
    toast('Создана новая группа с вложенными группами', 'success');
};
const closeGroupModal = () => {
                el('hp-modal-container').innerHTML = '';
            };
            const getParentId = (parentArray) => {
                if (parentArray === state.structure) return null;
                const findParent = (arr) => {
                    for (let item of arr) {
                        if (item.type === 'group' && item.children === parentArray) return item.id;
                        if (item.type === 'group' && item.children) {
                            const found = findParent(item.children);
                            if (found !== undefined) return found;
                        }
                    }
                    return undefined;
                };
                return findParent(state.structure);
            };
const renderStructureItem = (item, index, parentArray, parentLogic = null) => {
    const parentId = getParentId(parentArray);
    
    // Проверка, выделен ли элемент
    const isSelected = state.selection.includes(item.id);
    const selectedClass = isSelected ? 'selected' : '';

    // Логика отображения инпута вероятности (без изменений)
    let probabilityInput = '';
    if (parentLogic === 'OR') {
        const prob = item.probability !== undefined ? item.probability : (100 / parentArray.length);
        const isLocked = item.isLocked || false;
        
        probabilityInput = `
            <div class="prob-input-wrapper" style="display:flex; flex-direction:column; align-items:center; margin-right:8px;" onclick="event.stopPropagation()">
                <div style="display:flex; align-items:center; gap:2px;">
                    <label style="font-size:10px; color:#e65100; font-weight:bold;">% вер.</label>
                    <span onclick="app.toggleLock(${item.id})" style="cursor:pointer; font-size:12px;" title="Зафиксировать значение">
                        ${isLocked ? '🔒' : '🔓'}
                    </span>
                </div>
                <input type="number" class="hp-input hp-input-sm probability-input ${isLocked ? 'locked' : ''}" 
                    style="width: 55px; text-align:center; border:1px solid ${isLocked ? '#999' : '#ff9800'}; 
                    color:${isLocked ? '#666' : '#e65100'}; font-weight:bold; background:${isLocked ? '#eee' : '#fff'};"
                    min="0" max="100" step="0.1"
                    ${isLocked ? 'disabled' : ''} 
                    value="${Math.round(prob * 10) / 10}" 
                    onblur="app.updateItemProbability(${item.id}, this.value, ${parentId})"
                    onkeydown="if(event.key === 'Enter') { app.updateItemProbability(${item.id}, this.value, ${parentId}); this.blur(); }"
                    data-item-id="${item.id}"
                    data-parent-id="${parentId}">
            </div>
        `;
    }

    // --- Рендеринг ЭТАПА ---
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step) return '';
        
        const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
        const respNames = participants.length > 0 ? participants.map(p => p.name).join(', ') : '-';
        
        const hoursMin = Math.floor(step.timeMin / 60);
        const minutesMin = step.timeMin % 60;
        const hoursMax = Math.floor(step.timeMax / 60);
        const minutesMax = step.timeMax % 60;

        const timeStrMin = hoursMin > 0 ? `${hoursMin}ч ${minutesMin}мин` : `${minutesMin}мин`;
        const timeStrMax = hoursMax > 0 ? `${hoursMax}ч ${minutesMax}мин` : `${minutesMax}мин`;
        const timeStr = `${timeStrMin} — ${timeStrMax}`;
        const respCount = participants.length > 1 ? ` (${participants.length} чел.)` : '';
        
        return `
<div class="item-wrapper" style="display:flex; align-items:center; width:100%">
    ${probabilityInput} 
    
    <div class="step-item selectable-item ${selectedClass}" 
         data-item-id="${item.id}" 
         style="flex:1; padding-left: 5px; cursor: grab;"
         draggable="true"
         ondragstart="app.handleDragStart(event, ${item.id}, ${parentId})"
         ondragend="app.handleDragEnd(event, ${item.id})"
         onclick="event.stopPropagation(); app.toggleSelection(${item.id})"
         onmousedown="app.handleStepMouseDown(event)">
        
        <div class="drag-handle-integrated" 
            style="pointer-events: none;" 
            onmousedown="event.stopPropagation()">
        </div>

            <div class="step-number">#${step.uiId}</div>
            <div class="step-content">
                <div class="step-name">${step.action}</div>
                <div class="step-time">${timeStr} / Отв: ${respNames}${respCount}</div>
            </div>
        </div>
    </div>
`;
    } 
    // --- Рендеринг ГРУППЫ ---
    else if (item.type === 'group') {
        const logicLabels = {
            AND: 'И (Параллельно)',
            OR: 'ИЛИ (Альтернатива)',
            SEQ: 'Последовательно'
        };
        const groupClass = item.logic === 'AND' ? 'group-and' : (item.logic === 'OR' ? 'group-or' : 'group-seq');
        const groupLabel = logicLabels[item.logic];
        
        return `
<div class="item-wrapper" style="width: 100%; display:flex; align-items:flex-start;">
    ${probabilityInput} 
    <div class="group-wrapper" style="flex:1">
        
        <div class="group-container selectable-item ${item.logic === 'SEQ' ? 'group-seq' : (item.logic === 'OR' ? 'group-or' : 'group-and')} ${selectedClass}" 
             data-item-id="${item.id}"
             draggable="true"
             ondragstart="app.handleDragStart(event, ${item.id}, ${parentId})"
             ondragend="app.handleDragEnd(event, ${item.id})"
             onclick="event.stopPropagation(); app.toggleSelection(${item.id})"
             onmousedown="app.handleGroupMouseDown(event)">
             
            <div class="group-header ${groupClass}" style="cursor: grab;">
                <div class="drag-handle-integrated" 
                    style="font-size:14px; margin-right:2px; pointer-events: none;"
                    onmousedown="event.stopPropagation()">
                    
                </div>

                    <span onclick="event.stopPropagation(); app.changeGroupType(${item.id})" class="group-type-selector" title="Переключить тип группы">
                        ${groupLabel}
                    </span>
                    <span class="group-close" onclick="event.stopPropagation(); app.ungroupItems(${item.id})" title="Разгруппировать">
                        ✖
                    </span>
                </div>
                
                <div class="group-content">
                    ${item.children ? item.children.map((child, idx) => `
                        ${idx === 0 ? `<div class="drop-zone" ondragover="app.handleDragOver(event)" ondragenter="app.handleDragEnter(event)" ondragleave="app.handleDragLeave(event)" ondrop="app.handleDropOnGroupChild(event, ${item.id}, 0)"></div>` : ''}
                        ${renderStructureItem(child, idx, item.children, item.logic)} 
                        <div class="drop-zone" ondragover="app.handleDragOver(event)" ondragenter="app.handleDragEnter(event)" ondragleave="app.handleDragLeave(event)" ondrop="app.handleDropOnGroupChild(event, ${item.id}, ${idx + 1})"></div>
                    `).join('') : ''}
                </div>
            </div>
        </div>
    </div>
`;
    }
    return '';
};
const renderGroups = () => {
                const container = el('steps-container');
                if (state.structure.length === 0) {
                    container.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">Нет элементов. Добавьте этапы в разделе "Этапы".</div>';
                    return;
                }
                container.innerHTML = `
            <div class="steps-list">
                ${state.structure.map((item, index) => `
                    ${index === 0 ? `<div class="drop-zone" ondragover="app.handleDragOver(event)" ondragenter="app.handleDragEnter(event)" ondragleave="app.handleDragLeave(event)" ondrop="app.handleDropOnRoot(event, 0)"></div>` : ''}
                    ${renderStructureItem(item, index, state.structure)}
                    <div class="drop-zone" ondragover="app.handleDragOver(event)" ondragenter="app.handleDragEnter(event)" ondragleave="app.handleDragLeave(event)" ondrop="app.handleDropOnRoot(event, ${index + 1})"></div>
                `).join('')}
            </div>
        `;
            };
            
            
const toggleLock = (itemId) => {
        const findAndLock = (arr) => {
            for (let item of arr) {
                if (item.id === itemId) {
                    item.isLocked = !item.isLocked;
                    return true;
                }
                if (item.children && findAndLock(item.children)) return true;
            }
            return false;
        };
        findAndLock(state.structure);
        save();
        renderGroups();
    };          
            
const calculateTime = (item) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step) return { min: 0, avg: 0, max: 0 };
        const avgTime = (step.timeMin + step.timeMax) / 2;
        return { min: step.timeMin, avg: avgTime, max: step.timeMax };
    }
    if (item.type === 'group') {
        const childResults = item.children.map(child => calculateTime(child));
        if (item.logic === 'AND') {
            const min = Math.max(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            const avg = Math.max(...childResults.map(r => r.avg));
            return { min, avg, max };
        } else if (item.logic === 'OR') {
            const min = Math.min(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            
            // Расчет средневзвешенного
            let weightedAvg = 0;
            item.children.forEach((child, idx) => {
                let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                weightedAvg += childResults[idx].avg * (prob / 100);
            });
            return { min, avg: weightedAvg, max };
        } else if (item.logic === 'SEQ') {
            const min = childResults.reduce((sum, r) => sum + r.min, 0);
            const max = childResults.reduce((sum, r) => sum + r.max, 0);
            const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
            return { min, avg, max };
        }
    }
    return { min: 0, avg: 0, max: 0 };
};

// Вспомогательная функция для расчета стоимости этапа с учетом всех участников
// ДОБАВЬТЕ ЭТУ ФУНКЦИЮ ПЕРЕД calculateResults (если ее еще нет):
const calculateStepCost = (step, timeMinutes) => {
    if (!step || !step.respIds || step.respIds.length === 0) return 0;
    
    const participants = step.respIds.map(id => 
        state.part.find(p => p.id === id)
    ).filter(p => p);
    
    const totalRate = participants.reduce((sum, p) => sum + (p.rate || 0), 0);
    return (timeMinutes / 60) * totalRate;
};
// Вспомогательная функция для расчета человеко-часов этапа
const calculateStepManHours = (step, timeMinutes) => {
    if (!step) return 0;
    const participantCount = step.respIds ? step.respIds.length : 1;
    return (timeMinutes / 60) * participantCount;
};

// --- ЗАМЕНИТЬ ФУНКЦИЮ calculateCost ЦЕЛИКОМ ---
    const calculateCost = (item) => {
        if (item.type === 'step') {
            const step = state.steps.find(s => s.id === item.stepId);
            if (!step) return { min: 0, avg: 0, max: 0 };
            
            const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
            
            // 1. Считаем стоимость работы людей (как и раньше)
            const laborCostMin = participants.reduce((sum, part) => sum + (step.timeMin / 60) * part.rate, 0);
            const laborCostMax = participants.reduce((sum, part) => sum + (step.timeMax / 60) * part.rate, 0);
            const laborCostAvg = (laborCostMin + laborCostMax) / 2;

            // 2. НОВОЕ: Считаем стоимость входных ресурсов для ЭТОГО этапа
            let stepInputResourcesCost = 0;
            if (step.inputs && Array.isArray(step.inputs)) {
                step.inputs.forEach(resName => {
                    // Если ресурс НЕ производится внутри процесса, значит он внешний и платный
                    if (!allStepOutputs.has(resName)) {
                        const resource = state.resources.find(r => r.name === resName);
                        if (resource && resource.cost) {
                            stepInputResourcesCost += resource.cost;
                        }
                    }
                });
            }

            // 3. Суммируем работу и ресурсы
            return { 
                min: laborCostMin + stepInputResourcesCost, 
                avg: laborCostAvg + stepInputResourcesCost, 
                max: laborCostMax + stepInputResourcesCost 
            };
        }
        
        // Логика групп остается прежней
        if (item.type === 'group') {
            const childResults = item.children.map(child => calculateCost(child));
            if (item.logic === 'AND' || item.logic === 'SEQ') {
                const min = childResults.reduce((sum, r) => sum + r.min, 0);
                const max = childResults.reduce((sum, r) => sum + r.max, 0);
                const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
                return { min, avg, max };
            } else if (item.logic === 'OR') {
                const min = Math.min(...childResults.map(r => r.min));
                const max = Math.max(...childResults.map(r => r.max));
                
                let weightedAvg = 0;
                item.children.forEach((child, idx) => {
                    let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                    weightedAvg += childResults[idx].avg * (prob / 100);
                });
                return { min, avg: weightedAvg, max };
            }
        }
        return { min: 0, avg: 0, max: 0 };
    };
const collectParticipantStats = (item, participantStats, scenario) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step || !step.respIds || step.respIds.length === 0) return;
        
        step.respIds.forEach(participantId => {
            const part = state.part.find(p => p.id === participantId);
            if (!part) return;
            
            let timeToUse, costToUse, hoursToUse;
            
            if (scenario === 'min') {
                timeToUse = step.timeMin;
                costToUse = part ? (step.timeMin / 60) * part.rate : 0;
                hoursToUse = step.timeMin / 60;
            } else if (scenario === 'max') {
                timeToUse = step.timeMax;
                costToUse = part ? (step.timeMax / 60) * part.rate : 0;
                hoursToUse = step.timeMax / 60;
            } else if (scenario === 'avg') {
                const avgTime = (step.timeMin + step.timeMax) / 2;
                timeToUse = avgTime;
                costToUse = part ? (avgTime / 60) * part.rate : 0;
                hoursToUse = avgTime / 60;
            }

            if (!participantStats[participantId]) {
                participantStats[participantId] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
            }

            const S = scenario.charAt(0).toUpperCase() + scenario.slice(1);
            participantStats[participantId][`t${S}`] += timeToUse;
            participantStats[participantId][`c${S}`] += costToUse;
            participantStats[participantId][`mh${S}`] += hoursToUse;
            participantStats[participantId][`count${S}`]++;
        });
        return;
    }

    if (item.type === 'group') {
        if (item.logic === 'AND' || item.logic === 'SEQ') {
            item.children.forEach(child => collectParticipantStats(child, participantStats, scenario));
        } else if (item.logic === 'OR') {
            if (scenario === 'min' || scenario === 'max') {
                const allChildStats = item.children.map(child => {
                    const stats = {};
                    collectParticipantStats(child, stats, scenario);
                    return stats;
                });
                
                const allPids = new Set();
                allChildStats.forEach(s => Object.keys(s).forEach(pid => allPids.add(pid)));

                allPids.forEach(pid => {
                    if (!participantStats[pid]) participantStats[pid] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
                    const S = scenario.charAt(0).toUpperCase() + scenario.slice(1);
                    const values = allChildStats.map(s => s[pid] ? s[pid][`t${S}`] : 0);
                    // Для Min/Max в OR берем экстремумы (худший/лучший сценарий)
                    participantStats[pid][`t${S}`] += (scenario === 'min') ? Math.min(...values) : Math.max(...values);
                    // Аналогично для стоимости и ч-ч
                    const cValues = allChildStats.map(s => s[pid] ? s[pid][`c${S}`] : 0);
                    participantStats[pid][`c${S}`] += (scenario === 'min') ? Math.min(...cValues) : Math.max(...cValues);
                    const mhValues = allChildStats.map(s => s[pid] ? s[pid][`mh${S}`] : 0);
                    participantStats[pid][`mh${S}`] += (scenario === 'min') ? Math.min(...mhValues) : Math.max(...mhValues);
                });
            } else if (scenario === 'avg') {
                // ВАЖНО: Средневзвешенный расчет для участников
                item.children.forEach(child => {
                    const childStats = {};
                    collectParticipantStats(child, childStats, 'avg');
                    let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                    const weight = prob / 100;

                    Object.keys(childStats).forEach(pid => {
                        if (!participantStats[pid]) participantStats[pid] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
                        participantStats[pid].tAvg += childStats[pid].tAvg * weight;
                        participantStats[pid].cAvg += childStats[pid].cAvg * weight;
                        participantStats[pid].mhAvg += childStats[pid].mhAvg * weight;
                    });
                });
            }
        }
    }
};

const handleStepMouseDown = (e) => {
    // Проверяем, не кликнули ли на интерактивный элемент
    const interactiveSelectors = [
        'input',
        'button',
        'select',
        'textarea',
        '.drag-handle-integrated',
        '.group-type-selector',
        '.group-close',
        '.probability-input'
    ];
    
    const isInteractive = interactiveSelectors.some(selector => 
        e.target.matches(selector) || e.target.closest(selector)
    );
    
    if (isInteractive) {
        e.stopPropagation();
        return;
    }
    
    // Разрешаем перетаскивание
    e.dataTransfer = e.dataTransfer || new DataTransfer();
};

const handleGroupMouseDown = (e) => {
    // Проверяем, не кликнули ли на интерактивный элемент в заголовке группы
    const interactiveSelectors = [
        'input',
        'button',
        'select',
        'textarea',
        '.drag-handle-integrated',
        '.group-type-selector',
        '.group-close',
        '.probability-input'
    ];
    
    const isInteractive = interactiveSelectors.some(selector => 
        e.target.matches(selector) || e.target.closest(selector)
    );
    
    if (isInteractive) {
        e.stopPropagation();
        return;
    }
    
    // Разрешаем перетаскивание
    e.dataTransfer = e.dataTransfer || new DataTransfer();
};

const calculateManHours = (item) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step) return { min: 0, avg: 0, max: 0 };
        
        // ИСПРАВЛЕНО: Учитываем количество участников
        const participantCount = step.respIds ? step.respIds.length : 1;
        const mhMin = (step.timeMin / 60) * participantCount;
        const mhMax = (step.timeMax / 60) * participantCount;
        const mhAvg = (mhMin + mhMax) / 2;
        return { min: mhMin, avg: mhAvg, max: mhMax };
    }
    if (item.type === 'group') {
        const childResults = item.children.map(child => calculateManHours(child));
        if (item.logic === 'AND' || item.logic === 'SEQ') {
            const min = childResults.reduce((sum, r) => sum + r.min, 0);
            const max = childResults.reduce((sum, r) => sum + r.max, 0);
            const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
            return { min, avg, max };
        } else if (item.logic === 'OR') {
            const min = Math.min(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            
            let weightedAvg = 0;
            item.children.forEach((child, idx) => {
                let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                weightedAvg += childResults[idx].avg * (prob / 100);
            });
            return { min, avg: weightedAvg, max };
        }
    }
    return { min: 0, avg: 0, max: 0 };
};            
            
            
            
            
// Вспомогательная функция для анализа влияния этапов на участника
const getParticipantImpacts = (participantId) => {
    const impacts = [];
    
    // Рекурсивный обход для сбора "эффективного" времени этапов с учетом вероятностей
    const traverse = (node, probability) => {
        if (node.type === 'step') {
            const step = state.steps.find(s => s.id === node.stepId);
            if (step) {
                // Определяем, участвует ли этот участник в этапе
                const isResponsible = step.respIds && step.respIds.includes(participantId);
                
                // Эффективное время (время этапа * вероятность его возникновения)
                // Для ИЛИ групп вероятность < 1, для обычных = 1
                const factor = probability; 
                
                impacts.push({
                    name: step.action,
                    isResponsible: isResponsible,
                    // Сохраняем "взвешенное" время для сортировки и отображения вклада
                    tMin: step.timeMin * factor,
                    tAvg: ((step.timeMin + step.timeMax) / 2) * factor,
                    tMax: step.timeMax * factor
                });
            }
        } else if (node.type === 'group') {
            node.children.forEach(child => {
                let childProb = probability;
                // Если группа ИЛИ, умножаем текущую вероятность на вероятность ветки
                if (node.logic === 'OR') {
                    const prob = (child.probability !== undefined) ? child.probability : (100 / node.children.length);
                    childProb = probability * (prob / 100);
                }
                traverse(child, childProb);
            });
        }
    };

    state.structure.forEach(node => traverse(node, 1));
    
    // Сортируем по среднему времени убывания
    impacts.sort((a, b) => b.tAvg - a.tAvg);
    return impacts;
};

// Функция для форматирования списка топ-этапов
const formatTopImpacts = (impactList, baseMin, baseAvg, baseMax, isNegative = false) => {
    if (impactList.length === 0) return '<span style="color:#999;font-size:11px">—</span>';
    
    return impactList.slice(0, 5).map(item => {
        // Защита от деления на ноль
        const pMin = baseMin > 0 ? (item.tMin / baseMin * 100) : 0;
        const pAvg = baseAvg > 0 ? (item.tAvg / baseAvg * 100) : 0;
        const pMax = baseMax > 0 ? (item.tMax / baseMax * 100) : 0;
        
        // Знак +/-
        const sign = isNegative ? '-' : '+';
        const color = isNegative ? '#dc3545' : '#28a745'; // Красный для минуса (ожидание), Зеленый для плюса (работа)
        // Либо наоборот, если хотите: Красный (нагрузка), Синий (ожидание).
        // Оставим: Зеленый текст для "активной работы", Серый/Оранжевый для "ожидания".
        
        const style = isNegative ? 'color:#e65100' : 'color:#2a7a39';

        return `
            <div style="font-size:11px; margin-bottom:4px; line-height:1.2; border-bottom:1px dashed #eee; padding-bottom:2px;">
                <span style="font-weight:600; color:#333">${item.name}</span><br>
                <span style="${style}">
                    Мин: ${sign}${pMin.toFixed(1)}%, 
                    Прогн.: ${sign}${pAvg.toFixed(1)}%, 
                    Макс: ${sign}${pMax.toFixed(1)}%
                </span>
            </div>
        `;
    }).join('');
};            
            
            
            
const calculateResults = () => {
    if (state.structure.length === 0) {
        toast('Добавьте этапы и настройте структуру', 'error');
        return;
    }

    const formatHoursAndMinutes = (totalMinutes) => {
        const minutes = Math.round(totalMinutes);
        const hours = minutes / 60;
        return `${hours.toFixed(1)} ч (${minutes} мин)`;
    };
    
    // --- ВСТАВИТЬ В НАЧАЛО calculateResults ---
    
    // 1. Определяем, какие ресурсы создаются внутри процесса (являются выходами)
    const allStepOutputs = new Set();
    state.steps.forEach(s => {
        if (s.outputs && Array.isArray(s.outputs)) {
            s.outputs.forEach(r => allStepOutputs.add(r));
        }
    });

    // 1. БАЗОВЫЕ ФУНКЦИИ РАСЧЕТА
const calculateTime = (item) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step) return { min: 0, avg: 0, max: 0 };
        const avgTime = (step.timeMin + step.timeMax) / 2;
        return { min: step.timeMin, avg: avgTime, max: step.timeMax };
    }
    if (item.type === 'group') {
        const childResults = item.children.map(child => calculateTime(child));
        if (item.logic === 'AND') {
            const min = Math.max(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            const avg = Math.max(...childResults.map(r => r.avg));
            return { min, avg, max };
        } else if (item.logic === 'OR') {
            const min = Math.min(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            
            // Расчет средневзвешенного
            let weightedAvg = 0;
            item.children.forEach((child, idx) => {
                let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                weightedAvg += childResults[idx].avg * (prob / 100);
            });
            return { min, avg: weightedAvg, max };
        } else if (item.logic === 'SEQ') {
            const min = childResults.reduce((sum, r) => sum + r.min, 0);
            const max = childResults.reduce((sum, r) => sum + r.max, 0);
            const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
            return { min, avg, max };
        }
    }
    return { min: 0, avg: 0, max: 0 };
};

// --- ЗАМЕНИТЬ ФУНКЦИЮ calculateCost ЦЕЛИКОМ ---
    const calculateCost = (item) => {
        if (item.type === 'step') {
            const step = state.steps.find(s => s.id === item.stepId);
            if (!step) return { min: 0, avg: 0, max: 0 };
            
            const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
            
            // 1. Считаем стоимость работы людей (как и раньше)
            const laborCostMin = participants.reduce((sum, part) => sum + (step.timeMin / 60) * part.rate, 0);
            const laborCostMax = participants.reduce((sum, part) => sum + (step.timeMax / 60) * part.rate, 0);
            const laborCostAvg = (laborCostMin + laborCostMax) / 2;

            // 2. НОВОЕ: Считаем стоимость входных ресурсов для ЭТОГО этапа
            let stepInputResourcesCost = 0;
            if (step.inputs && Array.isArray(step.inputs)) {
                step.inputs.forEach(resName => {
                    // Если ресурс НЕ производится внутри процесса, значит он внешний и платный
                    if (!allStepOutputs.has(resName)) {
                        const resource = state.resources.find(r => r.name === resName);
                        if (resource && resource.cost) {
                            stepInputResourcesCost += resource.cost;
                        }
                    }
                });
            }

            // 3. Суммируем работу и ресурсы
            return { 
                min: laborCostMin + stepInputResourcesCost, 
                avg: laborCostAvg + stepInputResourcesCost, 
                max: laborCostMax + stepInputResourcesCost 
            };
        }
        
        // Логика групп остается прежней
        if (item.type === 'group') {
            const childResults = item.children.map(child => calculateCost(child));
            if (item.logic === 'AND' || item.logic === 'SEQ') {
                const min = childResults.reduce((sum, r) => sum + r.min, 0);
                const max = childResults.reduce((sum, r) => sum + r.max, 0);
                const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
                return { min, avg, max };
            } else if (item.logic === 'OR') {
                const min = Math.min(...childResults.map(r => r.min));
                const max = Math.max(...childResults.map(r => r.max));
                
                let weightedAvg = 0;
                item.children.forEach((child, idx) => {
                    let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                    weightedAvg += childResults[idx].avg * (prob / 100);
                });
                return { min, avg: weightedAvg, max };
            }
        }
        return { min: 0, avg: 0, max: 0 };
    };
const calculateManHours = (item) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step) return { min: 0, avg: 0, max: 0 };
        
        // ИСПРАВЛЕНО: Учитываем количество участников
        const participantCount = step.respIds ? step.respIds.length : 1;
        const mhMin = (step.timeMin / 60) * participantCount;
        const mhMax = (step.timeMax / 60) * participantCount;
        const mhAvg = (mhMin + mhMax) / 2;
        return { min: mhMin, avg: mhAvg, max: mhMax };
    }
    if (item.type === 'group') {
        const childResults = item.children.map(child => calculateManHours(child));
        if (item.logic === 'AND' || item.logic === 'SEQ') {
            const min = childResults.reduce((sum, r) => sum + r.min, 0);
            const max = childResults.reduce((sum, r) => sum + r.max, 0);
            const avg = childResults.reduce((sum, r) => sum + r.avg, 0);
            return { min, avg, max };
        } else if (item.logic === 'OR') {
            const min = Math.min(...childResults.map(r => r.min));
            const max = Math.max(...childResults.map(r => r.max));
            
            let weightedAvg = 0;
            item.children.forEach((child, idx) => {
                let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                weightedAvg += childResults[idx].avg * (prob / 100);
            });
            return { min, avg: weightedAvg, max };
        }
    }
    return { min: 0, avg: 0, max: 0 };
};
    // 2. СБОР СТАТИСТИКИ ПО УЧАСТНИКАМ (ИСПРАВЛЕНО)
    const participantStats = {};
    
const collectParticipantStats = (item, participantStats, scenario) => {
    if (item.type === 'step') {
        const step = state.steps.find(s => s.id === item.stepId);
        if (!step || !step.respIds || step.respIds.length === 0) return;
        
        step.respIds.forEach(participantId => {
            const part = state.part.find(p => p.id === participantId);
            if (!part) return;
            
            let timeToUse, costToUse, hoursToUse;
            
            if (scenario === 'min') {
                timeToUse = step.timeMin;
                costToUse = part ? (step.timeMin / 60) * part.rate : 0;
                hoursToUse = step.timeMin / 60;
            } else if (scenario === 'max') {
                timeToUse = step.timeMax;
                costToUse = part ? (step.timeMax / 60) * part.rate : 0;
                hoursToUse = step.timeMax / 60;
            } else if (scenario === 'avg') {
                const avgTime = (step.timeMin + step.timeMax) / 2;
                timeToUse = avgTime;
                costToUse = part ? (avgTime / 60) * part.rate : 0;
                hoursToUse = avgTime / 60;
            }

            if (!participantStats[participantId]) {
                participantStats[participantId] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
            }

            const S = scenario.charAt(0).toUpperCase() + scenario.slice(1);
            participantStats[participantId][`t${S}`] += timeToUse;
            participantStats[participantId][`c${S}`] += costToUse;
            participantStats[participantId][`mh${S}`] += hoursToUse;
            participantStats[participantId][`count${S}`]++;
        });
        return;
    }

    if (item.type === 'group') {
        if (item.logic === 'AND' || item.logic === 'SEQ') {
            item.children.forEach(child => collectParticipantStats(child, participantStats, scenario));
        } else if (item.logic === 'OR') {
            if (scenario === 'min' || scenario === 'max') {
                const allChildStats = item.children.map(child => {
                    const stats = {};
                    collectParticipantStats(child, stats, scenario);
                    return stats;
                });
                
                const allPids = new Set();
                allChildStats.forEach(s => Object.keys(s).forEach(pid => allPids.add(pid)));

                allPids.forEach(pid => {
                    if (!participantStats[pid]) participantStats[pid] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
                    const S = scenario.charAt(0).toUpperCase() + scenario.slice(1);
                    const values = allChildStats.map(s => s[pid] ? s[pid][`t${S}`] : 0);
                    // Для Min/Max в OR берем экстремумы (худший/лучший сценарий)
                    participantStats[pid][`t${S}`] += (scenario === 'min') ? Math.min(...values) : Math.max(...values);
                    // Аналогично для стоимости и ч-ч
                    const cValues = allChildStats.map(s => s[pid] ? s[pid][`c${S}`] : 0);
                    participantStats[pid][`c${S}`] += (scenario === 'min') ? Math.min(...cValues) : Math.max(...cValues);
                    const mhValues = allChildStats.map(s => s[pid] ? s[pid][`mh${S}`] : 0);
                    participantStats[pid][`mh${S}`] += (scenario === 'min') ? Math.min(...mhValues) : Math.max(...mhValues);
                });
            } else if (scenario === 'avg') {
                // ВАЖНО: Средневзвешенный расчет для участников
                item.children.forEach(child => {
                    const childStats = {};
                    collectParticipantStats(child, childStats, 'avg');
                    let prob = (child.probability !== undefined) ? child.probability : (100 / item.children.length);
                    const weight = prob / 100;

                    Object.keys(childStats).forEach(pid => {
                        if (!participantStats[pid]) participantStats[pid] = { tMin: 0, tMax: 0, tAvg: 0, cMin: 0, cMax: 0, cAvg: 0, mhMin: 0, mhMax: 0, mhAvg: 0, countMin: 0, countMax: 0, countAvg: 0 };
                        participantStats[pid].tAvg += childStats[pid].tAvg * weight;
                        participantStats[pid].cAvg += childStats[pid].cAvg * weight;
                        participantStats[pid].mhAvg += childStats[pid].mhAvg * weight;
                    });
                });
            }
        }
    }
};

    // ВЫЗОВ СБОРА СТАТИСТИКИ
    state.structure.forEach(item => {
        collectParticipantStats(item, participantStats, 'min');
        collectParticipantStats(item, participantStats, 'avg');
        collectParticipantStats(item, participantStats, 'max');
    });



    // 4. РАСЧЕТ ОБЩИХ ПОКАЗАТЕЛЕЙ
    const processTime = calculateTime({ type: 'group', logic: 'SEQ', children: state.structure });
    const processCost = calculateCost({ type: 'group', logic: 'SEQ', children: state.structure });
    const processManHours = calculateManHours({ type: 'group', logic: 'SEQ', children: state.structure });

const minCostWithInputs = processCost.min;
    const avgCostWithInputs = processCost.avg;
    const maxCostWithInputs = processCost.max;

    // 5. ОБНОВЛЕНИЕ UI
    // Обновите эти строки тоже, чтобы единицы измерения были серыми
el('res-cost-min').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${Math.round(minCostWithInputs).toLocaleString()}</span>
    <span style="font-size:28px;font-weight:600;margin-left:2px;">₽</span>
`;

el('res-cost').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${Math.round(avgCostWithInputs).toLocaleString()}</span>
    <span style="font-size:28px;font-weight:600;margin-left:2px;">₽</span>
`;

el('res-cost-max').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${Math.round(maxCostWithInputs).toLocaleString()}</span>
    <span style="font-size:28px;font-weight:600;margin-left:2px;">₽</span>
`;
    
// Первый блок (Длительность процесса)
el('res-time-min').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${(processTime.min / 60).toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч.</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processTime.min)} мин)</div>
`;

el('res-time').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${(processTime.avg / 60).toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч.</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processTime.avg)} мин)</div>
`;

el('res-time-max').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${(processTime.max / 60).toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч.</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processTime.max)} мин)</div>
`;
    
// Второй блок (Трудозатраты / Человеко-часы)
el('res-manhours-min').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${processManHours.min.toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч-ч</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processManHours.min * 60)} мин)</div>
`;

el('res-manhours-avg').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${processManHours.avg.toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч-ч</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processManHours.avg * 60)} мин)</div>
`;

el('res-manhours-max').innerHTML = `
    <span style="font-size:38px;font-weight:800;color:rgba(51, 51, 51, 0.95);">${processManHours.max.toFixed(1)}</span>
    <span style="font-size:32px;font-weight:600;margin-left:2px;">ч-ч</span>
    <div style="font-size:24px;color:rgba(136,136,136,0.7);font-weight:500;margin-top:4px;letter-spacing:0.2px;">(${Math.round(processManHours.max * 60)} мин)</div>
`;

    // 6. ТАБЛИЦА ТРУДОЗАТРАТ
    const tb = el('table-load').querySelector('tbody');
    tb.innerHTML = '';
    const tableData = [];
    Object.keys(participantStats).forEach(pid => {
        const s = participantStats[pid];
        const part = state.part.find(p => p.id === parseInt(pid));
        if (part && !part.excludeFromStats) { 
            tableData.push({
                name: part.name,
                tMin: s.tMin, tAvg: s.tAvg, tMax: s.tMax,
                cMin: s.cMin, cAvg: s.cAvg, cMax: s.cMax,
                mhMin: s.mhMin, mhAvg: s.mhAvg, mhMax: s.mhMax
            });
        }
    });
    tableData.sort((a, b) => b.cAvg - a.cAvg);
    if (tableData.length === 0) {
        tb.innerHTML = '<tr><td colspan="10" style="text-align:center;color:#999">Нет данных</td></tr>';
} else {
    tableData.forEach(d => {
        tb.innerHTML += `
        <tr>
            <td><b>${d.name}</b></td>
            <td style="color:#666">${formatHoursAndMinutes(d.tMin)}</td>
            <td style="color:#666">${formatHoursAndMinutes(d.tAvg)}</td>
            <td style="color:#666">${formatHoursAndMinutes(d.tMax)}</td>
            <td style="color:#666">${Math.round(d.cMin).toLocaleString()} ₽</td>
            <td style="color:#666">${Math.round(d.cAvg).toLocaleString()} ₽</td>
            <td style="color:#666">${Math.round(d.cMax).toLocaleString()} ₽</td>
            
            <td style="color:#666">${d.mhMin.toFixed(1)} ч-ч (${Math.round(d.mhMin * 60)} мин)</td>
            <td style="color:#666">${d.mhAvg.toFixed(1)} ч-ч (${Math.round(d.mhAvg * 60)} мин)</td>
            <td style="color:#666">${d.mhMax.toFixed(1)} ч-ч (${Math.round(d.mhMax * 60)} мин)</td>
        </tr>`;
    });
}
// --- ЕДИНЫЙ БЛОК РАСЧЕТА И СОРТИРОВКИ ДЛЯ ОБЕИХ ТАБЛИЦ ---
    
    // 1. Хелперы для форматирования
    const getLoadColor = (val) => (val > 120 ? '#c43e3e' : val > 100 ? '#e35757' : val < 50 ? '#579ae3' : '#7ea2c2');
    const formatLoad = (val) => `${val.toFixed(1)}%`;

    // 2. Собираем единый массив данных для всех участников
    const combinedParticipantsData = [];

    Object.keys(participantStats).forEach(pid => {
        const s = participantStats[pid];
        const part = state.part.find(p => p.id === parseInt(pid));
        const available = part ? (part.availableTime || 0) : 0;
        
        if (part && !part.excludeFromStats) {
            // Получаем детальную разбивку по этапам
            const allImpacts = getParticipantImpacts(part.id);
            const increaseImpacts = allImpacts.filter(i => i.isResponsible);
            const decreaseImpacts = allImpacts.filter(i => !i.isResponsible);

            // Расчеты для Таблицы 1 (Процесс)
            const procLoadMin = processTime.min > 0 ? (s.tMin / processTime.min) * 100 : 0;
            const procLoadAvg = processTime.avg > 0 ? (s.tAvg / processTime.avg) * 100 : 0;
            const procLoadMax = processTime.max > 0 ? (s.tMax / processTime.max) * 100 : 0;

            // Расчеты для Таблицы 2 (Доступность)
            const capLoadMin = available > 0 ? (s.tMin / available) * 100 : 0;
            const capLoadAvg = available > 0 ? (s.tAvg / available) * 100 : 0;
            const capLoadMax = available > 0 ? (s.tMax / available) * 100 : 0;

            combinedParticipantsData.push({
                name: part.name,
                available: available,
                // Данные для первой таблицы
                process: {
                    min: procLoadMin,
                    avg: procLoadAvg,
                    max: procLoadMax,
                    topInc: formatTopImpacts(increaseImpacts, processTime.min, processTime.avg, processTime.max, false),
                    topDec: formatTopImpacts(decreaseImpacts, processTime.min, processTime.avg, processTime.max, true)
                },
                // Данные для второй таблицы
                capacity: {
                    min: capLoadMin,
                    avg: capLoadAvg,
                    max: capLoadMax,
                    // Если доступное время 0, то и влияние считать бессмысленно/нельзя
                    topInc: available > 0 ? formatTopImpacts(increaseImpacts, available, available, available, false) : '<span style="color:#ccc">—</span>',
                    topDec: available > 0 ? formatTopImpacts(decreaseImpacts, available, available, available, true) : '<span style="color:#ccc">—</span>'
                }
            });
        }
    });

    // 3. СОРТИРОВКА: Сортируем один раз по нагрузке в процессе (от большей к меньшей)
    // Теперь порядок в массиве зафиксирован для обеих таблиц
    combinedParticipantsData.sort((a, b) => b.process.avg - a.process.avg);


    // --- 7. РЕНДЕРИНГ ТАБЛИЦЫ НАГРУЗКИ (ПРОЦЕСС) ---
    const tbParticipantLoad = el('table-participant-load').querySelector('tbody');
    
    if (combinedParticipantsData.length === 0) {
        tbParticipantLoad.innerHTML = `<tr><td colspan="6" style="text-align:center;color:#999">Нет данных</td></tr>`;
    } else {
        tbParticipantLoad.innerHTML = combinedParticipantsData.map(p => `
            <tr style="vertical-align: top;">
                <td style="padding-top:10px;"><b>${p.name}</b></td>
                <td style="color:${getLoadColor(p.process.min)}; padding-top:10px;">${formatLoad(p.process.min)}</td>
                <td style="color:${getLoadColor(p.process.avg)}; padding-top:10px;">${formatLoad(p.process.avg)}</td>
                <td style="color:${getLoadColor(p.process.max)}; padding-top:10px;">${formatLoad(p.process.max)}</td>
                <td style="background:#f9fbf9;">${p.process.topInc}</td>
                <td style="background:#fff5f5;">${p.process.topDec}</td>
            </tr>
        `).join('');
    }


    // --- 8. РЕНДЕРИНГ ТАБЛИЦЫ НАГРУЗКИ (ДОСТУПНОСТЬ) ---
    const tbCapacityLoad = el('table-participant-capacity-load').querySelector('tbody');
    
    if (combinedParticipantsData.length === 0) {
        tbCapacityLoad.innerHTML = `<tr><td colspan="7" style="text-align:center;color:#999">Нет данных</td></tr>`;
    } else {
        tbCapacityLoad.innerHTML = combinedParticipantsData.map(p => `
            <tr style="vertical-align: top;">
                <td style="padding-top:10px;"><b>${p.name}</b></td>
                <td style="padding-top:10px;">${p.available > 0 ? Math.floor(p.available/60)+'ч '+p.available%60+'м' : '—'}</td>
                <td style="color:${getLoadColor(p.capacity.min)}; padding-top:10px;">${p.available ? formatLoad(p.capacity.min) : '—'}</td>
                <td style="color:${getLoadColor(p.capacity.avg)}; padding-top:10px;">${p.available ? formatLoad(p.capacity.avg) : '—'}</td>
                <td style="color:${getLoadColor(p.capacity.max)}; padding-top:10px;">${p.available ? formatLoad(p.capacity.max) : '—'}</td>

            </tr>
        `).join('');
    }

   // 9. РЕСУРСЫ
const tbResourceCosts = el('table-resource-costs').querySelector('tbody');
tbResourceCosts.innerHTML = '';
const usedOutputResources = new Set();

// Собираем множество шагов в структуре для корректного подсчета
const stepsInStructure = new Set();
const collectStepsFromStructure = (items) => {
    items.forEach(item => {
        if (item.type === 'step') {
            stepsInStructure.add(item.stepId);
        } else if (item.type === 'group' && item.children) {
            collectStepsFromStructure(item.children);
        }
    });
};
collectStepsFromStructure(state.structure);

// Вспомогательная функция для расчета стоимости этапа
const calculateStepCost = (step, timeMinutes) => {
    if (!step || !step.respIds || step.respIds.length === 0) return 0;
    
    const participants = step.respIds.map(id => 
        state.part.find(p => p.id === id)
    ).filter(p => p);
    
    const totalRate = participants.reduce((sum, p) => sum + (p.rate || 0), 0);
    return (timeMinutes / 60) * totalRate;
};

// НОВАЯ ФУНКЦИЯ: Сбор данных о ресурсах для конкретного сценария
const collectResourceDataForScenario = (scenario) => {
    const resourceData = {};
    const usedOutputResources = new Set(); // Если это используется глобально

    const traverse = (node, probability = 1) => {
        if (node.type === 'step') {
            const step = state.steps.find(s => s.id === node.stepId);
            if (!step || !step.outputs || step.outputs.length === 0) return;

            let stepTime = 0;
            if (scenario === 'min') stepTime = step.timeMin;
            else if (scenario === 'max') stepTime = step.timeMax;
            else if (scenario === 'avg') stepTime = (step.timeMin + step.timeMax) / 2;

            // В min/max мы НЕ умножаем на вероятность внутри OR, 
            // так как там вероятность либо 0%, либо 100% для конкретного случая.
            // Но мы сохраняем входную probability от родительских AND групп.
            const currentProb = (scenario === 'avg') ? probability : probability; 
            
            const stepCost = calculateStepCost(step, stepTime) * currentProb;
            const weightedTime = stepTime * currentProb;

            step.outputs.forEach(resName => {
                if (!resourceData[resName]) {
                    resourceData[resName] = {
                        cost: 0,
                        time: 0,
                        sources: new Set(),
                        requiredInputs: new Set()
                    };
                }
                resourceData[resName].cost += stepCost;
                resourceData[resName].time += weightedTime;
                resourceData[resName].sources.add(`#${step.uiId} ${step.action}`);
                (step.inputs || []).forEach(inputName => 
                    resourceData[resName].requiredInputs.add(inputName)
                );
            });

        } else if (node.type === 'group') {
            if (node.logic === 'OR') {
                if (scenario === 'avg') {
                    // Для среднего — стандартный расчет по вероятностям
                    node.children.forEach(child => {
                        const childProb = (child.probability !== undefined) ? 
                            parseFloat(child.probability) : (100 / node.children.length);
                        traverse(child, probability * (childProb / 100));
                    });
                } else if (scenario === 'max') {
                    // Для MAX: мы хотим увидеть максимально возможную стоимость ресурсов.
                    // Собираем данные по каждой ветке отдельно и берем максимум для каждого ресурса.
                    const branchesData = node.children.map(child => {
                        const tempStore = {};
                        // Временная функция, чтобы не загрязнять основной resourceData
                        const subTraverse = (subNode, store) => {
                            // ... (логика аналогична traverse, но пишет в store)
                        };
                        // Но проще: для MAX в OR мы просто проходим по всем веткам с вероятностью 1 
                        // и выбираем максимальное влияние на каждый ресурс.
                        // Однако, чтобы не усложнять рекурсию, сделаем так:
                        // В сценарии MAX мы считаем, что ЛЮБАЯ ветка OR может случиться.
                        // Чтобы ресурс показал свой максимум, мы должны пройти по той ветке, где он есть.
                    });
                    
                    // Упрощенный подход для корректного отображения границ:
                    // В OR min - ресурс может быть 0. В OR max - ресурс равен своей стоимости в этой ветке.
                    node.children.forEach(child => {
                        if (scenario === 'max') {
                            traverse(child, probability); 
                        } else {
                            // Для min в OR: если ресурс не присутствует во ВСЕХ ветках, его min = 0.
                            // В текущей архитектуре проще всего пропустить ветки для min, 
                            // если только это не обязательные шаги.
                        }
                    });
                }
            } else {
                // AND и SEQ
                node.children.forEach(child => traverse(child, probability));
            }
        }
    };

    // ОПТИМАЛЬНОЕ РЕШЕНИЕ:
    // Чтобы расчет был верным, нам нужно изменить подход к OR в min/max.
    // Вместо "одного пути для всего сценария" используем "максимальный потенциал ресурса".
    
    const finalTraverse = (node, prob = 1) => {
        if (node.type === 'step') {
            const step = state.steps.find(s => s.id === node.stepId);
            if (!step) return;
            
            let time = (scenario === 'min') ? step.timeMin : (scenario === 'max' ? step.timeMax : (step.timeMin + step.timeMax)/2);
            let cost = calculateStepCost(step, time) * prob;
            
            // Обрабатываем выходные ресурсы
            if (step.outputs && step.outputs.length > 0) {
                step.outputs.forEach(res => {
                    if (!resourceData[res]) {
                        resourceData[res] = { 
                            cost: 0, 
                            time: 0, 
                            sources: new Set(),
                            requiredInputs: new Set() 
                        };
                    }
                    resourceData[res].cost += cost;
                    resourceData[res].time += time * prob;
                    resourceData[res].sources.add(`#${step.uiId} ${step.action}`);
                    
                    // Добавляем входные ресурсы как requiredInputs
                    if (step.inputs && step.inputs.length > 0) {
                        step.inputs.forEach(inputName => {
                            resourceData[res].requiredInputs.add(inputName);
                        });
                    }
                });
            }
        } else {
            if (node.logic === 'OR') {
                if (scenario === 'avg') {
                    node.children.forEach(c => {
                        let p = (c.probability !== undefined) ? parseFloat(c.probability)/100 : 1/node.children.length;
                        finalTraverse(c, prob * p);
                    });
                } else if (scenario === 'max') {
                    node.children.forEach(c => finalTraverse(c, prob));
                } else if (scenario === 'min') {
                    // Для min пропускаем (ресурс может быть 0)
                }
            } else {
                node.children.forEach(c => finalTraverse(c, prob));
            }
        }
    };

    state.structure.forEach(root => finalTraverse(root));
    return resourceData;
};

// Собираем данные для всех сценариев
const resourceDataMin = collectResourceDataForScenario('min');
const resourceDataAvg = collectResourceDataForScenario('avg');
const resourceDataMax = collectResourceDataForScenario('max');

// ПОДСЧЕТ КОЛИЧЕСТВА ИСПОЛЬЗОВАНИЙ РЕСУРСОВ КАК ВХОДНЫХ
const inputUsageCount = {};
state.steps.forEach(step => {
    // Учитываем только шаги, которые есть в структуре
    if (stepsInStructure.has(step.id) && step.inputs && Array.isArray(step.inputs)) {
        step.inputs.forEach(resourceName => {
            inputUsageCount[resourceName] = (inputUsageCount[resourceName] || 0) + 1;
        });
    }
});

// Сбор данных ресурсов для таблицы
const allResourceData = [];

// Выходные ресурсы
Object.keys(resourceDataAvg).forEach(resName => {
    const avg = resourceDataAvg[resName];
    const min = resourceDataMin[resName] || { cost:0, time:0, sources: new Set(), requiredInputs: new Set() };
    const max = resourceDataMax[resName] || { cost:0, time:0, sources: new Set(), requiredInputs: new Set() };
    
    // Гарантируем правильный порядок min <= avg <= max
    const finalCosts = {
        min: Math.min(min.cost, avg.cost, max.cost),
        avg: avg.cost,
        max: Math.max(min.cost, avg.cost, max.cost)
    };
    
    const finalTimes = {
        min: Math.min(min.time, avg.time, max.time),
        avg: avg.time,
        max: Math.max(min.time, avg.time, max.time)
    };
    
    allResourceData.push({
        name: resName,
        minCost: finalCosts.min,
        maxCost: finalCosts.max,
        avgCost: finalCosts.avg,
        minTime: finalTimes.min,
        maxTime: finalTimes.max,
        sources: Array.from(avg.sources || new Set()),
        requiredInputs: Array.from(avg.requiredInputs || new Set()),
        usageCount: inputUsageCount[resName] || 0,
        type: 'выходной'
    });
});

// Входные ресурсы
// Входные ресурсы (только те, которые НЕ являются выходными)
const allUsedResources = new Set();
state.steps.forEach(s => { 
    if (stepsInStructure.has(s.id)) {
        (s.inputs||[]).forEach(r => allUsedResources.add(r)); 
        // УБРАТЬ ЭТУ СТРОКУ: (s.outputs||[]).forEach(r => allUsedResources.add(r));
    }
});

// Определяем, какие ресурсы являются выходными (создаются в процессе)
const outputResources = new Set(Object.keys(resourceDataAvg));

Array.from(allUsedResources).forEach(resName => {
    // Если ресурс создается в процессе (является выходным), пропускаем его
    if (outputResources.has(resName)) {
        return;
    }
    
    const r = state.resources.find(x => x.name === resName);
    const cost = r ? (r.cost || 0) : 0;
    
    // Собираем информацию о том, где используется этот входной ресурс
    const sources = [];
    state.steps.forEach(s => {
        if (stepsInStructure.has(s.id) && s.inputs && s.inputs.includes(resName)) {
            sources.push(`#${s.uiId} ${s.action}`);
        }
    });
    
    allResourceData.push({
        name: resName, 
        minCost: cost, 
        maxCost: cost, 
        avgCost: cost,
        minTime: 0, 
        maxTime: 0, 
        sources: sources.length > 0 ? sources : ['внешний источник'], 
        requiredInputs: [], 
        usageCount: inputUsageCount[resName] || 0,
        type: 'входной'
    });
});

// Сортируем по убыванию средней стоимости
allResourceData.sort((a, b) => b.avgCost - a.avgCost);

// Рендерим таблицу
if (allResourceData.length === 0) {
    tbResourceCosts.innerHTML = `<tr><td colspan="6" style="text-align:center;color:#999">Нет данных</td></tr>`;
} else {
    tbResourceCosts.innerHTML = allResourceData.map(res => `
        <tr>
            <td><b>${res.name}</b> ${res.type==='входной'?'<span style="color:#999;font-size:11px;">(входной)</span>':''}</td>
            <td>${Math.round(res.minCost)} ₽ — ${Math.round(res.maxCost)} ₽</td>
            <td>${(res.minTime/60).toFixed(1)} ч — ${(res.maxTime/60).toFixed(1)} ч</td>
            <td style="color:#666">${res.sources.join(', ')}</td>
            <td style="color:#2a508b;font-weight:bold">${res.requiredInputs.join(', ') || '—'}</td>
            <td style="color:#666; text-align:center; font-weight:bold">${res.usageCount}</td>
        </tr>
    `).join('');
}

    // 10. ГРАФИКИ (Этапы)
// 10. ГРАФИКИ (Этапы)
const stepsData = state.steps.map(s => {
    // ИСПРАВЛЕНО: Учитываем всех участников
    const participants = s.respIds ? s.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
    const totalRate = participants.reduce((sum, p) => sum + p.rate, 0);
    
    const avg = (s.timeMin + s.timeMax) / 2;
    return { 
        name: s.action, 
        timeMin: s.timeMin, 
        timeAvg: avg, 
        timeMax: s.timeMax, 
        costMin: (s.timeMin / 60) * totalRate, 
        costAvg: (avg / 60) * totalRate, 
        costMax: (s.timeMax / 60) * totalRate 
    };
});

const topCostSteps = [...stepsData].sort((a, b) => b.costAvg - a.costAvg).slice(0, 10);
    renderHorizontalGroupedChart('chart-top-cost-steps', topCostSteps.map(s => s.name), topCostSteps.map(s => s.costMin), topCostSteps.map(s => s.costAvg), topCostSteps.map(s => s.costMax), ' ₽');
    const topTimeSteps = [...stepsData].sort((a, b) => b.timeAvg - a.timeAvg).slice(0, 10);
    renderHorizontalGroupedChart('chart-top-time-steps', topTimeSteps.map(s => s.name), topTimeSteps.map(s => s.timeMin), topTimeSteps.map(s => s.timeAvg), topTimeSteps.map(s => s.timeMax), ' мин');

    // 11. ГРАФИКИ (Участники) - ИСПОЛЬЗУЕМ СОБРАННЫЕ ДАННЫЕ
    const sortedParticipants = tableData.map(d => d.name);
    const pTimeMin = [], pTimeAvg = [], pTimeMax = [], pCostMin = [], pCostAvg = [], pCostMax = [], pMhMin = [], pMhAvg = [], pMhMax = [];
    sortedParticipants.forEach(name => {
        const d = tableData.find(x => x.name === name);
        pTimeMin.push(Math.round(d.tMin)); pTimeAvg.push(Math.round(d.tAvg)); pTimeMax.push(Math.round(d.tMax));
        pCostMin.push(Math.round(d.cMin)); pCostAvg.push(Math.round(d.cAvg)); pCostMax.push(Math.round(d.cMax));
        pMhMin.push(d.mhMin); pMhAvg.push(d.mhAvg); pMhMax.push(d.mhMax);
    });
    renderGroupedChart('chart-part-time', sortedParticipants, pTimeMin, pTimeAvg, pTimeMax, ' мин');
    renderGroupedChart('chart-part-cost', sortedParticipants, pCostMin, pCostAvg, pCostMax, ' ₽');
    renderGroupedChart('chart-part-manhours', sortedParticipants, pMhMin, pMhAvg, pMhMax, ' ч-ч');

// 12. ГРАФИКИ (Ресурсы) - УБЕДИТЕСЬ, ЧТО ДАННЫЕ ПРАВИЛЬНЫЕ
const topRes = allResourceData.filter(r => r.type === 'выходной').slice(0, 15);
if (topRes.length > 0) {
    // Заменяем renderGroupedChart на renderTwoBarsChart
    renderTwoBarsChart('chart-res-time', 
        topRes.map(r => r.name), 
        topRes.map(r => Math.round(r.minTime)), 
        topRes.map(r => Math.round(r.maxTime)), 
        ' мин'
    );
    
    renderTwoBarsChart('chart-res-cost', 
        topRes.map(r => r.name), 
        topRes.map(r => Math.round(r.minCost)), 
        topRes.map(r => Math.round(r.maxCost)), 
        ' ₽'
    );
}

    // 13. ДЕКОМПОЗИЦИЯ
    renderDecompositionTable(); 
    renderDecompositionCharts();

    toast('Результаты пересчитаны', 'success');
};




// --- НОВАЯ ФУНКЦИЯ ДЛЯ ТАБЛИЦЫ ДЕКОМПОЗИЦИИ ---
// --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ДЕКОМПОЗИЦИИ ---
// --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ДЛЯ ТАБЛИЦЫ ДЕКОМПОЗИЦИИ ---
const renderDecompositionTable = () => {
    const tbody = el('table-decomposition').querySelector('tbody');
    tbody.innerHTML = '';

    // 1. ВМЕСТО ТОГО ЧТОБЫ СЧИТАТЬ ЗАНОВО, БЕРЕМ ГОТОВЫЕ ДАННЫЕ ИЗ ГРАФИКОВ
    const data = getDecompositionData();

    if (!data || data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;color:#999">Нет данных</td></tr>';
        return;
    }

    // Хелперы для форматирования
    const fmtMoney = (val) => Math.round(val).toLocaleString() + ' ₽';
const fmtTime = (val) => {
    const h = (val / 60).toFixed(1);
    const m = Math.round(val);
    return `${h} ч <span style="color:#999;font-size:11px">(${m} мин)</span>`;
};

const fmtMH = (val) => {
    const m = Math.round(val * 60);
    return `${val.toFixed(1)} ч-ч <span style="color:#999;font-size:11px">(${m} мин)</span>`;
};
    let prev = { 
        tMin: 0, tAvg: 0, tMax: 0, 
        cMin: 0, cAvg: 0, cMax: 0, 
        mhMin: 0, mhAvg: 0, mhMax: 0 
    };

    data.forEach((row, index) => {
        const renderCell = (curr, prevVal, formatter) => {
            const delta = curr - prevVal;
            
            if (index === 0) {
                return `<div>${formatter(curr)}</div><div style="font-size:10px;color:#999">(старт)</div>`;
            }
            if (Math.abs(delta) < 0.001) {
                return `<div style="color:#777">${formatter(curr)}</div><div style="font-size:10px;color:#ccc">--</div>`;
            }

            let pct = 0;
            if (prevVal > 0.001) {
                pct = ((delta / prevVal) * 100);
            } else {
                pct = 100;
            }
            
            const pctStr = pct.toFixed(1);

// --- ОБНОВЛЕННАЯ ЛОГИКА ЦВЕТОВ (0-20-50) ---
let color = '#28a745'; // По умолчанию зеленый (до 20%)

if (pct >= 50) {
    color = '#dc3545'; // Красный (50% и выше)
} else if (pct >= 20) {
    color = '#ffc107'; // Желтый (от 20% до 50%)
}
// Если pct < 20, остается зеленый
// -------------------------------------------

            return `
                <div style="font-weight:500">${formatter(curr)}</div>
                <div style="font-size:10px; color:${color}; font-weight:bold">(+${pctStr}%)</div>
            `;
        };

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${row.stepNumber}</td>
            <td>${row.stepName}</td>

            <td>${renderCell(row.tMin, prev.tMin, fmtTime)}</td>
            <td>${renderCell(row.tAvg, prev.tAvg, fmtTime)}</td>
            <td>${renderCell(row.tMax, prev.tMax, fmtTime)}</td>

            <td>${renderCell(row.cMin, prev.cMin, fmtMoney)}</td>
            <td>${renderCell(row.cAvg, prev.cAvg, fmtMoney)}</td>
            <td>${renderCell(row.cMax, prev.cMax, fmtMoney)}</td>

            <td>${renderCell(row.mhMin, prev.mhMin, fmtMH)}</td>
            <td>${renderCell(row.mhAvg, prev.mhAvg, fmtMH)}</td>
            <td>${renderCell(row.mhMax, prev.mhMax, fmtMH)}</td>
        `;
        tbody.appendChild(tr);

        prev = row;
    });
};

// НОВАЯ ФУНКЦИЯ: Получение данных декомпозиции для графиков
// НОВАЯ ФУНКЦИЯ: Получение данных декомпозиции для графиков
const getDecompositionData = () => {
    if (state.structure.length === 0) return null;
    
    // Вспомогательная функция для расчета весов (критичности и вероятностей)
    const calculateWeights = () => {
        const weights = new Map();
        
        const calcWeightsRecursive = (node, wMin, wAvg, wMax, isCriticalTimeMin, isCriticalTimeAvg, isCriticalTimeMax) => {
            if (node.type === 'step') {
                const step = state.steps.find(s => s.id === node.stepId);
                if (!step) return { tMin:0, tAvg:0, tMax:0, cMin:0, cAvg:0, cMax:0, mhMin:0, mhAvg:0, mhMax:0 };
                
                // ИСПРАВЛЕНО: Получаем всех участников этапа
                const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
                const totalRate = participants.reduce((sum, p) => sum + (p.rate || 0), 0);
                const participantCount = participants.length;
                
                // Сохраняем веса для этого этапа
                weights.set(step.id, { 
                    wMin, wAvg, wMax, 
                    ctMin: isCriticalTimeMin, 
                    ctAvg: isCriticalTimeAvg, 
                    ctMax: isCriticalTimeMax 
                });
                
                // Возвращаем сырые данные (без весов)
                const rawTMin = step.timeMin;
                const rawTMax = step.timeMax;
                const rawTAvg = (step.timeMin + step.timeMax) / 2;
                const rawCMin = (step.timeMin / 60) * totalRate;
                const rawCMax = (step.timeMax / 60) * totalRate;
                const rawCAvg = ((step.timeMin + step.timeMax) / 2 / 60) * totalRate;
                const rawMhMin = (step.timeMin / 60) * participantCount;
                const rawMhMax = (step.timeMax / 60) * participantCount;
                const rawMhAvg = ((step.timeMin + step.timeMax) / 2 / 60) * participantCount;
                
                return {
                    tMin: rawTMin,
                    tMax: rawTMax,
                    tAvg: rawTAvg,
                    cMin: rawCMin,
                    cMax: rawCMax,
                    cAvg: rawCAvg,
                    mhMin: rawMhMin,
                    mhMax: rawMhMax,
                    mhAvg: rawMhAvg
                };
            }
            
            if (node.type === 'group') {
                const childResults = node.children.map(child => calcWeightsRecursive(child, wMin, wAvg, wMax, isCriticalTimeMin, isCriticalTimeAvg, isCriticalTimeMax));
                
                node.children.forEach((child, idx) => {
                    const d = childResults[idx];
                    let childWMin = wMin;
                    let childWMax = wMax;
                    let childWAvg = wAvg;
                    
                    let childCtMin = isCriticalTimeMin;
                    let childCtMax = isCriticalTimeMax;
                    let childCtAvg = isCriticalTimeAvg;

                    if (node.logic === 'OR') {
                        // MIN SCENARIO: Выбираем путь с минимальной стоимостью
                        const minVal = Math.min(...childResults.map(x => x.cMin));
                        if (Math.abs(d.cMin - minVal) > 0.01) childWMin = 0;
                        
                        // MAX SCENARIO: Выбираем путь с максимальной стоимостью
                        const maxVal = Math.max(...childResults.map(x => x.cMax));
                        if (Math.abs(d.cMax - maxVal) > 0.01) childWMax = 0;
                        
                        // AVG SCENARIO: Учитываем вероятность
                        let prob = (child.probability !== undefined) ? child.probability : (100 / node.children.length);
                        childWAvg = wAvg * (prob / 100);
                        
                        // Время для Min/Max в OR
                        const minTime = Math.min(...childResults.map(x => x.tMin));
                        if (Math.abs(d.tMin - minTime) > 0.01) childCtMin = false;
                        
                        const maxTime = Math.max(...childResults.map(x => x.tMax));
                        if (Math.abs(d.tMax - maxTime) > 0.01) childCtMax = false;
                    } 
                    else if (node.logic === 'AND') {
                        // Для AND вес стоимости полный, а время только критический путь
                        const maxTMin = Math.max(...childResults.map(x => x.tMin));
                        const maxTAvg = Math.max(...childResults.map(x => x.tAvg));
                        const maxTMax = Math.max(...childResults.map(x => x.tMax));
                        
                        if (Math.abs(d.tMin - maxTMin) > 0.01) childCtMin = false;
                        if (Math.abs(d.tMax - maxTMax) > 0.01) childCtMax = false;
                        if (Math.abs(d.tAvg - maxTAvg) > 0.01) childCtAvg = false;
                    }
                    
                    // Рекурсивный вызов с обновленными весами
                    calcWeightsRecursive(child, childWMin, childWAvg, childWMax, childCtMin, childCtAvg, childCtMax);
                });
                
                // Возвращаем агрегированные результаты для группы
                const traverse = (node) => {
                    if (node.type === 'step') {
                        const step = state.steps.find(s => s.id === node.stepId);
                        if (!step) return { tMin:0, tAvg:0, tMax:0, cMin:0, cAvg:0, cMax:0, mhMin:0, mhAvg:0, mhMax:0 };
                        
                        const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
                        const totalRate = participants.reduce((sum, p) => sum + (p.rate || 0), 0);
                        const participantCount = participants.length;
                        
                        return {
                            tMin: step.timeMin,
                            tMax: step.timeMax,
                            tAvg: (step.timeMin + step.timeMax) / 2,
                            cMin: (step.timeMin / 60) * totalRate,
                            cMax: (step.timeMax / 60) * totalRate,
                            cAvg: ((step.timeMin + step.timeMax) / 2 / 60) * totalRate,
                            mhMin: (step.timeMin / 60) * participantCount,
                            mhMax: (step.timeMax / 60) * participantCount,
                            mhAvg: ((step.timeMin + step.timeMax) / 2 / 60) * participantCount
                        };
                    } else if (node.type === 'group') {
                        const results = node.children.map(child => traverse(child));
                        const groupRes = { tMin:0, tAvg:0, tMax:0, cMin:0, cAvg:0, cMax:0, mhMin:0, mhAvg:0, mhMax:0 };
                        
                        if (node.logic === 'SEQ') {
                            results.forEach(r => {
                                groupRes.tMin += r.tMin; 
                                groupRes.tAvg += r.tAvg; 
                                groupRes.tMax += r.tMax;
                                groupRes.cMin += r.cMin; 
                                groupRes.cAvg += r.cAvg; 
                                groupRes.cMax += r.cMax;
                                groupRes.mhMin += r.mhMin; 
                                groupRes.mhAvg += r.mhAvg; 
                                groupRes.mhMax += r.mhMax;
                            });
                        } else if (node.logic === 'AND') {
                            groupRes.tMin = Math.max(...results.map(r => r.tMin));
                            groupRes.tAvg = Math.max(...results.map(r => r.tAvg));
                            groupRes.tMax = Math.max(...results.map(r => r.tMax));
                            
                            results.forEach(r => {
                                groupRes.cMin += r.cMin; 
                                groupRes.cAvg += r.cAvg; 
                                groupRes.cMax += r.cMax;
                                groupRes.mhMin += r.mhMin; 
                                groupRes.mhAvg += r.mhAvg; 
                                groupRes.mhMax += r.mhMax;
                            });
                        } else if (node.logic === 'OR') {
                            groupRes.tMin = Math.min(...results.map(r => r.tMin));
                            groupRes.tMax = Math.max(...results.map(r => r.tMax));
                            
                            // Взвешенное среднее
                            let weightedT = 0, weightedC = 0, weightedMH = 0;
                            node.children.forEach((child, i) => {
                                let prob = (child.probability !== undefined) ? child.probability : (100 / node.children.length);
                                weightedT += results[i].tAvg * (prob/100);
                                weightedC += results[i].cAvg * (prob/100);
                                weightedMH += results[i].mhAvg * (prob/100);
                            });
                            
                            groupRes.tAvg = weightedT;
                            groupRes.cAvg = weightedC;
                            groupRes.mhAvg = weightedMH;
                            
                            groupRes.cMin = Math.min(...results.map(r => r.cMin));
                            groupRes.cMax = Math.max(...results.map(r => r.cMax));
                            groupRes.mhMin = Math.min(...results.map(r => r.mhMin));
                            groupRes.mhMax = Math.max(...results.map(r => r.mhMax));
                        }
                        return groupRes;
                    }
                    return { tMin:0, tAvg:0, tMax:0, cMin:0, cAvg:0, cMax:0, mhMin:0, mhAvg:0, mhMax:0 };
                };
                
                return traverse(node);
            }
            return { tMin:0, tAvg:0, tMax:0, cMin:0, cAvg:0, cMax:0, mhMin:0, mhAvg:0, mhMax:0 };
        };

        state.structure.forEach(root => calcWeightsRecursive(root, 1, 1, 1, true, true, true));
        return weights;
    };

    const weights = calculateWeights();
    
    const orderedSteps = [];
    const getOrdered = (nodes) => {
        nodes.forEach(node => {
            if(node.type === 'step') {
                const s = state.steps.find(x => x.id === node.stepId);
                if(s) orderedSteps.push(s);
            } else if (node.children) {
                getOrdered(node.children);
            }
        });
    };
    getOrdered(state.structure);
    
    const result = [];
    let acc = { tMin: 0, tAvg: 0, tMax: 0, cMin: 0, cAvg: 0, cMax: 0, mhMin: 0, mhAvg: 0, mhMax: 0 };
    
    orderedSteps.forEach((step, index) => {
        const w = weights.get(step.id) || { wMin:0, wAvg:0, wMax:0, ctMin:false, ctAvg:false, ctMax:false };
        
        // ИСПРАВЛЕНО: Получаем всех участников этапа
        const participants = step.respIds ? step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
        const totalRate = participants.reduce((sum, p) => sum + (p.rate || 0), 0);
        const participantCount = participants.length;
        
        const rawTMin = step.timeMin;
        const rawTMax = step.timeMax;
        const rawTAvg = (step.timeMin + step.timeMax) / 2;
        const rawCMin = (step.timeMin / 60) * totalRate;
        const rawCMax = (step.timeMax / 60) * totalRate;
        const rawCAvg = ((step.timeMin + step.timeMax) / 2 / 60) * totalRate;
        const rawMhMin = (step.timeMin / 60) * participantCount;
        const rawMhMax = (step.timeMax / 60) * participantCount;
        const rawMhAvg = ((step.timeMin + step.timeMax) / 2 / 60) * participantCount;
        
        const eff = {
            cMin: rawCMin * (w.wMin || 0),
            cMax: rawCMax * (w.wMax || 0),
            cAvg: rawCAvg * (w.wAvg || 0),
            
            mhMin: rawMhMin * (w.wMin || 0),
            mhMax: rawMhMax * (w.wMax || 0),
            mhAvg: rawMhAvg * (w.wAvg || 0),
            
            tMin: (w.ctMin ? rawTMin : 0),
            tMax: (w.ctMax ? rawTMax : 0),
            tAvg: (w.ctAvg ? (rawTAvg * (w.wAvg || 0)) : (rawTAvg * (w.wAvg || 0)))
        };
        
        acc.tMin += eff.tMin;
        acc.tMax += eff.tMax;
        acc.tAvg += eff.tAvg;
        
        acc.cMin += eff.cMin;
        acc.cMax += eff.cMax;
        acc.cAvg += eff.cAvg;
        
        acc.mhMin += eff.mhMin;
        acc.mhMax += eff.mhMax;
        acc.mhAvg += eff.mhAvg;
        
        result.push({
            stepNumber: index + 1,
            stepName: step.action,
            ...JSON.parse(JSON.stringify(acc))
        });
    });
    
    return result;
};
// НОВАЯ ФУНКЦИЯ: Расчет площади выше диагонали
// ОБНОВЛЕННАЯ ФУНКЦИЯ: Расчет площади выше и ниже диагонали
// ОБНОВЛЕННАЯ ФУНКЦИЯ: Расчет площади выше и ниже диагонали с началом от первой точки
const calculateAreaDeviation = (data, maxX, maxY) => {
    if (data.length < 2) {
        return {
            areaAbove: 0,
            areaBelow: 0,
            totalArea: 0,
            percentageAbove: 0,
            percentageBelow: 0,
            totalDeviationPercentage: 0
        };
    }
    
    let areaAbove = 0;
    let areaBelow = 0;
    
    // НОВОЕ: Используем первую точку данных как начало диагонали
    const firstX = 1; // Первый этап (X=1)
    const firstY = data[0]; // Первое значение
    
    // НОВОЕ: Рассчитываем наклон диагонали от первой точки до последней
    const diagonalSlope = (maxY - firstY) / (maxX - firstX);
    
    // Проходим по всем точкам данных
    for (let i = 1; i < data.length; i++) {
        const x = i + 1; // Номер этапа (начинается с 1)
        const y = data[i];
        
        // НОВОЕ: Рассчитываем значение на диагонали для данного X
        const yDiagonal = firstY + (x - firstX) * diagonalSlope;
        
        if (y > yDiagonal) {
            // Площадь выше диагонали
            const segmentArea = (y - yDiagonal);
            areaAbove += segmentArea;
        } else {
            // Площадь ниже диагонали
            const segmentArea = (yDiagonal - y);
            areaBelow += segmentArea;
        }
    }
    
    // НОВОЕ: Общая площадь трапеции под диагональю
    const totalArea = ((firstY + maxY) * (maxX - firstX)) / 2;
    
    // Расчет процентов
    const percentageAbove = totalArea > 0 ? (areaAbove / totalArea) * 100 : 0;
    const percentageBelow = totalArea > 0 ? (areaBelow / totalArea) * 100 : 0;
    const totalDeviationPercentage = percentageAbove + percentageBelow;
    
    return {
        areaAbove: areaAbove,
        areaBelow: areaBelow,
        totalArea: totalArea,
        percentageAbove: percentageAbove,
        percentageBelow: percentageBelow,
        totalDeviationPercentage: totalDeviationPercentage,
        // НОВОЕ: Добавляем данные для построения диагонали
        diagonalStart: { x: firstX, y: firstY },
        diagonalEnd: { x: maxX, y: maxY },
        diagonalSlope: diagonalSlope
    };
};

// НОВАЯ ФУНКЦИЯ: Рендер графиков декомпозиции
// ОБНОВЛЕННАЯ ФУНКЦИЯ: Рендер графиков декомпозиции с расчетом отклонений
const renderDecompositionCharts = () => {
    const data = getDecompositionData();
    if (!data || data.length === 0) return;
    
    // Подготовка данных
    const labels = data.map(d => d.stepNumber);
    // ДОБАВИЛИ: получаем названия этапов для подсказок
    const stepNames = data.map(d => d.stepName); // <-- ДОБАВИЛИ ЭТУ СТРОКУ
    
    // Стоимость
    const costMinData = data.map(d => d.cMin);
    const costAvgData = data.map(d => d.cAvg);
    const costMaxData = data.map(d => d.cMax);
    
    // Время
    const timeMinData = data.map(d => d.tMin);
    const timeAvgData = data.map(d => d.tAvg);
    const timeMaxData = data.map(d => d.tMax);
    
    // Человеко-часы
    const mhMinData = data.map(d => d.mhMin);
    const mhAvgData = data.map(d => d.mhAvg);
    const mhMaxData = data.map(d => d.mhMax);
    
    // Массив для хранения информации о всех графиках
    const charts = [
        { 
            id: 'chart-decomp-cost-min', 
            data: costMinData, 
            title: 'Стоимость (Оптимистичный сценарий)', 
            yLabel: 'Стоимость, ₽', 
            suffix: '₽',
            belowElementId: 'diag-cost-min-below',
            aboveElementId: 'diag-cost-min-above',
            totalElementId: 'diag-cost-min-total'
        },
        { 
            id: 'chart-decomp-cost-avg', 
            data: costAvgData, 
            title: 'Стоимость (Прогнозируемый сценарий)', 
            yLabel: 'Стоимость, ₽', 
            suffix: '₽',
            belowElementId: 'diag-cost-avg-below',
            aboveElementId: 'diag-cost-avg-above',
            totalElementId: 'diag-cost-avg-total'
        },
        { 
            id: 'chart-decomp-cost-max', 
            data: costMaxData, 
            title: 'Стоимость (Максимальный сценарий)', 
            yLabel: 'Стоимость, ₽', 
            suffix: '₽',
            belowElementId: 'diag-cost-max-below',
            aboveElementId: 'diag-cost-max-above',
            totalElementId: 'diag-cost-max-total'
        },
        
        { 
            id: 'chart-decomp-time-min', 
            data: timeMinData, 
            title: 'Время (Оптимистичный сценарий)', 
            yLabel: 'Время, мин', 
            suffix: 'мин',
            belowElementId: 'diag-time-min-below',
            aboveElementId: 'diag-time-min-above',
            totalElementId: 'diag-time-min-total'
        },
        { 
            id: 'chart-decomp-time-avg', 
            data: timeAvgData, 
            title: 'Время (Прогнозируемый сценарий)', 
            yLabel: 'Время, мин', 
            suffix: 'мин',
            belowElementId: 'diag-time-avg-below',
            aboveElementId: 'diag-time-avg-above',
            totalElementId: 'diag-time-avg-total'
        },
        { 
            id: 'chart-decomp-time-max', 
            data: timeMaxData, 
            title: 'Время (Максимальный сценарий)', 
            yLabel: 'Время, мин', 
            suffix: 'мин',
            belowElementId: 'diag-time-max-below',
            aboveElementId: 'diag-time-max-above',
            totalElementId: 'diag-time-max-total'
        },
        
        { 
            id: 'chart-decomp-mh-min', 
            data: mhMinData, 
            title: 'Человеко-часы (Оптимистичный сценарий)', 
            yLabel: 'Человеко-часы', 
            suffix: 'ч-ч',
            belowElementId: 'diag-mh-min-below',
            aboveElementId: 'diag-mh-min-above',
            totalElementId: 'diag-mh-min-total'
        },
        { 
            id: 'chart-decomp-mh-avg', 
            data: mhAvgData, 
            title: 'Человеко-часы (Прогнозируемый сценарий)', 
            yLabel: 'Человеко-часы', 
            suffix: 'ч-ч',
            belowElementId: 'diag-mh-avg-below',
            aboveElementId: 'diag-mh-avg-above',
            totalElementId: 'diag-mh-avg-total'
        },
        { 
            id: 'chart-decomp-mh-max', 
            data: mhMaxData, 
            title: 'Человеко-часы (Максимальный сценарий)', 
            yLabel: 'Человеко-часы', 
            suffix: 'ч-ч',
            belowElementId: 'diag-mh-max-below',
            aboveElementId: 'diag-mh-max-above',
            totalElementId: 'diag-mh-max-total'
        }
    ];
    
charts.forEach(chart => {
    const ctx = document.getElementById(chart.id);
    if (!ctx) return;
    
    if (chartInstances[chart.id]) {
        chartInstances[chart.id].destroy();
    }
    
    const maxX = data.length;
    const maxY = Math.max(...chart.data);
    const areaInfo = calculateAreaDeviation(chart.data, maxX, maxY);
    
    // Обновляем текстовые поля с процентами
    if (chart.belowElementId) {
        const belowElement = document.getElementById(chart.belowElementId);
        if (belowElement) {
            const belowPercent = areaInfo.percentageBelow;
            belowElement.textContent = `${belowPercent.toFixed(1)}%`;
            belowElement.className = 'stat-value';
            if (belowPercent < 10) belowElement.classList.add('low');
            else if (belowPercent < 30) belowElement.classList.add('medium');
            else belowElement.classList.add('high');
        }
    }
    
    if (chart.aboveElementId) {
        const aboveElement = document.getElementById(chart.aboveElementId);
        if (aboveElement) {
            const abovePercent = areaInfo.percentageAbove;
            aboveElement.textContent = `${abovePercent.toFixed(1)}%`;
            aboveElement.className = 'stat-value';
            if (abovePercent < 10) aboveElement.classList.add('low');
            else if (abovePercent < 30) aboveElement.classList.add('medium');
            else aboveElement.classList.add('high');
        }
    }
    
    if (chart.totalElementId) {
        const totalElement = document.getElementById(chart.totalElementId);
        if (totalElement) {
            const totalPercent = areaInfo.totalDeviationPercentage;
            totalElement.textContent = `${totalPercent.toFixed(1)}%`;
            totalElement.className = 'stat-value';
            if (totalPercent < 20) totalElement.classList.add('low');
            else if (totalPercent < 50) totalElement.classList.add('medium');
            else totalElement.classList.add('high');
        }
    }
    
    // НОВОЕ: Данные для диагональной линии (начинается от первой точки)
    const diagonalData = [
        { x: areaInfo.diagonalStart.x, y: areaInfo.diagonalStart.y },
        { x: areaInfo.diagonalEnd.x, y: areaInfo.diagonalEnd.y }
    ];
    
    chartInstances[chart.id] = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Накопленное значение',
                    data: chart.data,
                    borderColor: 'rgb(54, 162, 235)',
                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointBackgroundColor: 'rgb(54, 162, 235)',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 4
                },
                {
                    label: 'Идеальная диагональ',
                    data: diagonalData, // Используем новые данные
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    type: 'line'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: chart.title,
                    font: { 
                        size: 16, 
                        weight: 'bold',
                        family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'
                    },
                    padding: { bottom: 10 }
                },
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        font: { size: 12 },
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        // ДОБАВИЛИ: колбэк для заголовка подсказки
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex;
                            if (stepNames[index]) {
                                return stepNames[index]; // Возвращаем название этапа
                            }
                            return `Этап ${index + 1}`; // Или номер этапа, если названия нет
                        },
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                if (chart.suffix === '₽') {
                                    label += context.parsed.y.toLocaleString() + ' ₽';
                                } else if (chart.suffix === 'мин') {
                                    const hours = (context.parsed.y / 60).toFixed(1);
                                    label += Math.round(context.parsed.y) + ' мин (' + hours + ' ч)';
                                } else {
                                    label += context.parsed.y.toFixed(1) + ' ' + chart.suffix;
                                }
                            }
                            return label;
                        }
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    titleColor: '#333',
                    bodyColor: '#666',
                    borderColor: '#e0e0e0',
                    borderWidth: 1,
                    padding: 12,
                    cornerRadius: 6
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Номер этапа',
                        font: { size: 13, weight: 'bold' }
                    },
                    grid: { 
                        color: '#f0f0f0',
                        drawBorder: false
                    },
                    ticks: {
                        font: { size: 11 }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: chart.yLabel,
                        font: { size: 13, weight: 'bold' }
                    },
                    beginAtZero: true,
                    grid: { 
                        color: '#f0f0f0',
                        borderDash: [5, 5]
                    },
                    ticks: {
                        font: { size: 11 }
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            },
            elements: {
                line: {
                    tension: 0.3
                }
            }
        }
    });
});
    
};
const downloadReportHTML = () => {
                calculateResults();
                const cloneDoc = document.documentElement.cloneNode(true);
                const dataScript = document.createElement('script');
                dataScript.textContent = `window.Mentor_REPORT_DATA = ${JSON.stringify(state)};`;
                cloneDoc.querySelector('head').insertBefore(dataScript, cloneDoc.querySelector('head').firstChild);
                const tabs = cloneDoc.querySelector('.hp-tabs');
                if (tabs) tabs.remove();
                const modals = cloneDoc.querySelectorAll('.hp-modal');
                modals.forEach(m => m.remove());
                const toastContainer = cloneDoc.querySelector('#hp-toast-container');
                if (toastContainer) toastContainer.innerHTML = '';
                const contentDivs = cloneDoc.querySelectorAll('.hp-content');
                contentDivs.forEach(div => {
                    if (div.id === 'tab-results') {
                        div.classList.add('active');
                        div.style.display = 'block';
                        const controls = div.querySelector('.hp-controls-row');
                        if (controls) controls.remove();
                    } else {
                        div.remove();
                    }
                });
                const header = document.createElement('div');
                header.style.cssText = "text-align:center; margin-bottom:30px; padding:20px; border-bottom:1px solid #eee; background: white; border-radius: 8px;";
                header.innerHTML = `
            <h1 style="margin:0; color:#333;">Отчет по бизнес-процессу</h1>
            <p style="color:#666; margin:5px 0 0;">Сформирован: ${new Date().toLocaleString()}</p>
        `;
                const appDiv = cloneDoc.querySelector('#Mentor-app');
                if (appDiv) appDiv.insertBefore(header, appDiv.firstChild);
                const htmlContent = "<!DOCTYPE html>\n" + cloneDoc.outerHTML;
                const blob = new Blob([htmlContent], {
                    type: 'text/html'
                });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'Process_Mentor_Отчет.html';
                link.click();
                toast('Интерактивный отчет скачан', 'success');
            };
            
const getResourceInfo = (resourceName) => {
    const sources = [];
    const components = new Set();
    const resource = state.resources.find(r => r.name === resourceName);
    const resourceCost = resource ? (resource.cost || 0) : 0;
    
    state.steps.forEach(step => {
        if (step.outputs && step.outputs.includes(resourceName)) {
            sources.push(`#${step.uiId} ${step.action}`);
            if (step.inputs) {
                step.inputs.forEach(inp => components.add(inp));
            }
        }
    });
    const type = sources.length > 0 ? 'Выходной' : 'Входной';
    return {
        type,
        components: Array.from(components),
        sources: sources.length > 0 ? sources : ['входной'],
        cost: resourceCost // Добавляем стоимость в информацию о ресурсе
    };
};            
            
   
  // --- Вспомогательная функция для генерации ячейки ресурсов ---
const generateResourceCellHTML = (resources, type, stepId) => {
    const count = resources ? resources.length : 0;
    const isInput = type === 'inputs';
    
    let tooltipContent = '';
    
    if (count === 0) {
        tooltipContent = `<div class="tooltip-empty-text">Ресурсы не выбраны.<br>Нажмите на кнопку настройки назначения ресурсов, чтобы выбрать нужный ресурс на этом этапе.</div>`;
    } else {
        const tagsHtml = resources.map(r => 
            `<span class="hp-tag ${isInput ? 'tag-blue' : 'tag-green'}" style="margin:2px; font-size:11px;">${r}</span>`
        ).join('');
        
        tooltipContent = `
            <div class="tooltip-header">${isInput ? 'Входящие ресурсы' : 'Выходящие ресурсы'}</div>
            <div style="display:flex; flex-wrap:wrap; justify-content:center; gap:4px;">${tagsHtml}</div>
        `;
    }

    return `
        <div class="resource-cell-wrapper">
            <button class="hp-btn hp-btn-sm" 
                    style="font-size: 20px; width: 40px; min-width: 40px; max-width: 40px; height: 30px; padding: 0; line-height: 1; display: flex; align-items: center; justify-content: center; flex-shrink: 0;" 
                    onclick="app.openEditResourcesModal(${stepId}, '${type}')">⚙</button>
            
            <div class="resource-count-badge ${count === 0 ? 'empty' : ''}">
                ${count}
            </div>

            <div class="resource-tooltip">
                ${tooltipContent}
            </div>
        </div>
    `;
}; 
   
            
const renderAll = () => {
    // 1. Рендеринг Участников
    const tbPart = el('table-part').querySelector('tbody');
    tbPart.innerHTML = '';
    state.part.forEach(p => {
        const avail = p.availableTime || 0;
        const h = Math.floor(avail / 60);
        const m = avail % 60;

        tbPart.innerHTML += `
        <tr data-part-id="${p.id}">
            <td><input type="text" class="hp-input hp-input-sm" value="${p.name}" onchange="app.updateParticipantValue(${p.id}, 'name', this.value)"></td>
            <td><input type="number" class="hp-input hp-input-sm" value="${p.rate}" onchange="app.updateParticipantValue(${p.id}, 'rate', this.value)"></td>
            <td>
                <div style="display:flex;gap:5px;align-items:center;">
                    <input type="number" class="hp-input hp-input-sm hp-time-hour" style="width:60px;" value="${h}" min="0" data-part-id="${p.id}"> ч
                    <input type="number" class="hp-input hp-input-sm hp-time-minute" style="width:60px;" value="${m}" min="0" max="59" data-part-id="${p.id}"> м
                </div>
            </td>
            <td style="text-align:center;">
                <input type="checkbox" style="width:18px; height:18px; cursor:pointer;" ${p.excludeFromStats ? 'checked' : ''} onchange="app.updateParticipantValue(${p.id}, 'excludeFromStats', this.checked)">
            </td>
            <td><button class="hp-btn hp-btn-danger hp-btn-sm" onclick="app.delPart(${p.id})">✖</button></td>
        </tr>
        `;
    });

    // 2. Рендеринг Ресурсов
    const tbResources = el('table-resources').querySelector('tbody');
    tbResources.innerHTML = '';
    const allRes = getAvailableResources();
    allRes.forEach(r => {
        const info = getResourceInfo(r); 
        const componentsStr = info.components.length > 0 ?
            info.components.map(c => `<span class="hp-tag tag-orange">${c}</span>`).join('') : '-';
        const sourcesStr = info.sources.join(', ');
        const resourceObj = state.resources.find(res => res.name === r);
        const costValue = resourceObj ? (resourceObj.cost || 0) : 0;
        
        tbResources.innerHTML += `
            <tr>
                <td>
                    <input type="text" class="hp-input hp-input-sm" value="${r}" data-old-name="${r}"
                        onblur="app.renameResourceEverywhere(this.dataset.oldName, this.value)"
                        onkeydown="if(event.key==='Enter') this.blur()">
                </td>
                <td style="color:#666; font-size:12px;">${info.type}</td>
                <td>
                    ${info.type === 'Входной' ? 
                        `<input type="number" class="hp-input hp-input-sm" value="${costValue}" onchange="app.updateResourceCost('${r}', this.value)" style="width: 100px;" placeholder="0"> ` : 
                        '<span style="color:#999; font-size:12px;">Рассчитывается в "Результаты"</span>'
                    }
                </td>
                <td style="font-size:12px;">${componentsStr}</td>
                <td style="color:#666; font-size:12px;">${sourcesStr}</td>
                <td style="text-align: center;">
                    <button class="hp-btn hp-btn-danger hp-btn-sm" style="font-size: 20px; font-weight: bold; line-height: 1; padding: 2px 10px;" onclick="app.delResource('${r}')" title="Удалить ресурс">&times;</button>
                </td>
            </tr>
        `;
    });

    // 3. Рендеринг Этапов (ИСПРАВЛЕННАЯ ЧАСТЬ)
    const tbSteps = el('table-steps').querySelector('tbody');
    tbSteps.innerHTML = '';
    
    state.steps.forEach(s => {
        const participants = s.respIds ? s.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p) : [];
        const respNames = participants.map(p => p.name).join(', ');
        
        const hoursMin = Math.floor(s.timeMin / 60);
        const minutesMin = s.timeMin % 60;
        const hoursMax = Math.floor(s.timeMax / 60);
        const minutesMax = s.timeMax % 60;
        
        // Используем новую функцию-помощник
        const inputsHtml = generateResourceCellHTML(s.inputs, 'inputs', s.id);
        const outputsHtml = generateResourceCellHTML(s.outputs, 'outputs', s.id);
        
        tbSteps.innerHTML += `
        <tr>
            <td><b>#${s.uiId}</b></td>
            <td><input type="text" class="hp-input hp-input-sm" value="${s.action}" onchange="app.updateStepValue(${s.id}, 'action', this.value)"></td>
            <td>
                <div style="position: relative;">
                    <input type="text" class="hp-input hp-input-sm" value="${respNames}" 
                        placeholder="Выберите ответственных" onclick="app.openResponsiblesSelector(${s.id}, this)"
                        readonly style="cursor: pointer; background: white;">
                    <div id="resp-dropdown-${s.id}" class="hp-dropdown" style="display: none;"></div>
                </div>
            </td>
            <td>
                <div style="display:flex;gap:10px;align-items:center;">
                    <div>
                        <div style="font-size:10px;color:#888">мин:</div>
                        <div style="display:flex;gap:2px;align-items:center;">
                            <input type="number" class="hp-input hp-input-sm" style="width:40px;" value="${hoursMin}" min="0" onchange="app.updateStepTimeMin(${s.id}, parseInt(this.value) || 0, ${minutesMin})">ч
                            <input type="number" class="hp-input hp-input-sm" style="width:40px;" value="${minutesMin}" min="0" max="59" onchange="app.updateStepTimeMin(${s.id}, ${hoursMin}, parseInt(this.value) || 0)">м
                        </div>
                    </div>
                    <div style="color:#888">-</div>
                    <div>
                        <div style="font-size:10px;color:#888">макс:</div>
                        <div style="display:flex;gap:2px;align-items:center;">
                            <input type="number" class="hp-input hp-input-sm" style="width:40px;" value="${hoursMax}" min="0" onchange="app.updateStepTimeMax(${s.id}, parseInt(this.value) || 0, ${minutesMax})">ч
                            <input type="number" class="hp-input hp-input-sm" style="width:40px;" value="${minutesMax}" min="0" max="59" onchange="app.updateStepTimeMax(${s.id}, ${hoursMax}, parseInt(this.value) || 0)">м
                        </div>
                    </div>
                </div>
            </td>
            
            <td style="overflow: visible;">${inputsHtml}</td>
            <td style="overflow: visible;">${outputsHtml}</td>
            
            <td><button class="hp-btn hp-btn-danger hp-btn-sm" onclick="app.delStep(${s.id})">✖</button></td>
        </tr>
        `;
    });

    renderGroups();
};

window.addEventListener('load', function() {
    // Инициализируем приложение после полной загрузки DOM
    setTimeout(function() {
        load();
        // Убеждаемся, что первая вкладка активна
        if (document.querySelector('.hp-tab.active')) {
            const activeTab = document.querySelector('.hp-tab.active').getAttribute('onclick');
            if (activeTab) {
                const tabId = activeTab.match(/'([^']+)'/)[1];
                app.switchTab(tabId);
            }
        }
        
        // Инициализируем пустые таблицы, если данных нет
        if (state.part.length === 0) {
            const tbPart = el('table-part')?.querySelector('tbody');
            if (tbPart) tbPart.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#999;">Добавьте первого участника</td></tr>';
        }
        
        toast('Приложение загружено', 'success');
    }, 100);
});

const findItemPosition = (itemId, arr = state.structure, depth = 0) => {
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (item.id === itemId) {
            return {
                parent: arr,
                index: i,
                depth
            };
        }
        if (item.type === 'group' && item.children) {
            const found = findItemPosition(itemId, item.children, depth + 1);
            if (found) return found;
        }
    }
    return null;
};


const openResponsiblesSelector = (stepId, inputElement) => {
    const step = state.steps.find(s => s.id === stepId);
    if (!step) return;
    
    const dropdownId = `resp-dropdown-${stepId}`;
    const dropdown = el(dropdownId);
    if (!dropdown) return;
    
    const currentRespIds = step.respIds || [];
    
    dropdown.innerHTML = state.part.map(p => `
        <div class="hp-dropdown-item" onclick="app.toggleStepResponsible(${stepId}, ${p.id}, this)">
            <input type="checkbox" style="margin-right: 8px;" ${currentRespIds.includes(p.id) ? 'checked' : ''}>
            ${p.name} <span style="color:#666; font-size:11px">(${p.rate} ₽/час)</span>
        </div>
    `).join('');
    
    dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    
    // Закрытие при клике вне
    const closeHandler = (e) => {
        if (!dropdown.contains(e.target) && e.target !== inputElement) {
            dropdown.style.display = 'none';
            document.removeEventListener('click', closeHandler);
        }
    };
    
    setTimeout(() => {
        document.addEventListener('click', closeHandler);
    }, 10);
};

const toggleStepResponsible = (stepId, partId, element) => {
    const step = state.steps.find(s => s.id === stepId);
    if (!step) return;
    
    if (!step.respIds) step.respIds = [];
    
    const index = step.respIds.indexOf(partId);
    if (index > -1) {
        step.respIds.splice(index, 1);
        element.querySelector('input').checked = false;
    } else {
        step.respIds.push(partId);
        element.querySelector('input').checked = true;
    }
    
    save();
    
    // Обновляем отображение в таблице
    const participants = step.respIds.map(id => state.part.find(p => p.id === id)).filter(p => p);
    const respNames = participants.map(p => p.name).join(', ');
    
    const row = element.closest('tr');
    if (row) {
        const inputField = row.querySelector('input[readonly]');
        if (inputField) {
            inputField.value = respNames;
        }
    }
};

const exportProject = (filenamePrefix = 'project_process') => {
    try {
        const payload = {
            meta: {
                exportedAt: new Date().toISOString(),
                appVersion: 'Mentor_data_v17' // Увеличиваем версию
            },
            part: state.part || [],
            resources: state.resources.map(r => ({ // Сохраняем ресурсы с полем cost
                id: r.id,
                name: r.name,
                cost: r.cost || 0
            })),
            steps: state.steps || [],
            structure: state.structure || [],
            temp: state.temp || {}
        };
        const jsonStr = JSON.stringify(payload, null, 2);
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(jsonStr);
        const a = document.createElement('a');
        const name = `${filenamePrefix}_${new Date().toISOString().slice(0,10)}.json`;
        a.setAttribute("href", dataStr);
        a.setAttribute("download", name);
        document.body.appendChild(a);
        a.click();
        a.remove();
        toast('Экспорт выполнен', 'success');
    } catch (err) {
        console.error('exportProject error', err);
        toast('Ошибка при экспорте', 'error');
    }
};

const triggerImport = () => {
    let input = document.getElementById('import-file-input');
    if (!input) {
        input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json';
        input.id = 'import-file-input';
        input.style.display = 'none';
        input.onchange = function () { importProject(this); };
        document.body.appendChild(input);
    }
    input.click();
};

const importProject = (inputElement) => {
    const file = inputElement.files ? inputElement.files[0] : null;
    if (!file) {
        toast('Файл не выбран', 'error');
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const json = JSON.parse(e.target.result);
            if (!json || !Array.isArray(json.part) || !Array.isArray(json.steps) || !Array.isArray(json.structure)) {
                toast('Файл не подходит (ожидается корректный экспорт)', 'error');
                return;
            }
            if (!confirm('Импорт заменит текущее состояние проекта данными из файла. Продолжить?')) return;
            state.part = Array.isArray(json.part) ? json.part.map(p => ({ ...p })) : [];
state.resources = Array.isArray(json.resources) ? json.resources.map(r => ({ 
    ...r, 
    cost: r.cost || 0 // Добавляем поле cost при импорте
})) : [];
state.steps = Array.isArray(json.steps) ? json.steps.map(s => ({ ...s })) : [];
state.structure = Array.isArray(json.structure) ? json.structure.map(s => ({ ...s })) : [];

state.temp = json.temp || { inputs: [], outputs: [], newStepInputs: [], newStepOutputs: [], editStepId: null, editStepInputs: [], editStepOutputs: [] };

// дополнительно: гарантируем, что у шагов есть поля времени/массивы
state.part.forEach(p => { if (p.rate !== undefined) p.rate = Number(p.rate) || 0; });
state.steps.forEach(s => {
    // совместимость: возможное старое поле time
    if (s.time !== undefined && (s.timeMin === undefined && s.timeMax === undefined)) {
        s.timeMin = Number(s.time) || 0;
        s.timeMax = Number(s.time) || 0;
        delete s.time;
    }
    s.timeMin = Number(s.timeMin) || 0;
    s.timeMax = Number(s.timeMax) || 0;
    if (!Array.isArray(s.inputs)) s.inputs = [];
    if (!Array.isArray(s.outputs)) s.outputs = [];
});
            save();
            try { renderAll(); } catch(e) { console.warn('renderAll после импорта упал', e); }
            toast('Импорт выполнен', 'success');
        } catch (err) {
            console.error('importProject error', err);
            toast('Ошибка чтения файла: неверный формат JSON', 'error');
        } finally {
            inputElement.value = '';
        }
    };
    reader.readAsText(file);
};



            
return {
    
    toggleAccordion: (element) => {
        const container = element.closest('.hp-accordion');
        container.classList.toggle('active');
        
        // Магия для исправления отрисовки графиков Chart.js внутри скрытых блоков
        if (container.classList.contains('active')) {
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 100);
        }
    },
    
    
switchTab: (id) => {
    document.querySelectorAll('.hp-content').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.hp-tab').forEach(x => x.classList.remove('active'));
    el(id).classList.add('active');
    document.querySelector(`.hp-tab[onclick*="${id}"]`).classList.add('active');
    
    // При переключении на вкладку результатов всегда обновляем расчеты
    if (id === 'tab-results') {
        setTimeout(() => {
            app.calculateResults();
        }, 50);
    }
},    
    
    addParticipant,
    handleStepMouseDown,
    handleGroupMouseDown,
    toggleSelection,
    clearSelection,
    executeAction,
    updateFloatingPanel,
    delPart,
    updateParticipantValue,
    updateParticipantAvailableTime,
    addResource,
    delResource,
    updateResourceValue,
    renameResourceEverywhere,
    openStepCreationModal,
    closeStepCreationModal,
    createNewStepFromModal,
    removeNewStepTempTag,
    removeNewStepTempOutputTag,
    delStep,
    updateStepValue,
    updateStepTimeMin,
    updateStepTimeMax,
    updateStepResponsible,
    openEditResourcesModal,
    closeEditResourcesModal,
    saveEditedResources,
    updateResourceCost,
    removeEditStepInputTag,
    removeEditStepOutputTag,
    openGroupModal,
    closeGroupModal,
    toggleCheckbox,
    updateActionDescription,
    handleGroupAction,
    generateResourceCellHTML,
    changeGroupType,
    updateItemProbability,  // ← ДОБАВЬТЕ ЭТУ СТРОКУ
    ungroupItems,
    setupNewStepResponsiblesSearch,
    renderNewStepResponsibles,
    removeNewStepResponsible,
    openResponsiblesSelector,
    toggleStepResponsible,
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    handleDragEnter,
    handleDragLeave,
    handleDropOnRoot,
    handleDropOnGroupChild,
    calculateResults,
    exportProject,
    toggleLock,
    triggerImport,
    importProject,
    downloadReportHTML,
    renderDecompositionTable,
    findItemPosition,
    getDecompositionData,
    renderDecompositionCharts,
    load
};        })();


const forceUpdateGroup = (groupId) => {
    const updateRecursive = (arr) => {
        for (let item of arr) {
            if (item.id === groupId && item.type === 'group') {
                // Просто перерисовываем группу
                return true;
            }
            if (item.type === 'group' && item.children) {
                if (updateRecursive(item.children)) return true;
            }
        }
        return false;
    };
    if (updateRecursive(state.structure)) {
        save();
        renderGroups();
        toast('Группа обновлена', 'success');
    }
};


// Обработчик для всех полей времени
document.addEventListener('input', function(e) {
    if (e.target.classList.contains('hp-time-hour') || 
        e.target.classList.contains('hp-time-minute')) {
        
        const partId = e.target.getAttribute('data-part-id');
        const row = e.target.closest('tr[data-part-id]');
        
        if (row && partId) {
            const hoursInput = row.querySelector('.hp-time-hour');
            const minutesInput = row.querySelector('.hp-time-minute');
            
            if (hoursInput && minutesInput) {
                // Задержка для оптимизации
                clearTimeout(window.timeUpdateTimeout);
                window.timeUpdateTimeout = setTimeout(() => {
                    app.updateParticipantAvailableTime(
                        parseInt(partId), 
                        hoursInput, 
                        minutesInput
                    );
                }, 500);
            }
        }
    }
});

// Автоматический пересчет при изменении доступного времени участников
document.addEventListener('DOMContentLoaded', function() {
    // Делегирование событий для динамически созданных элементов
    document.addEventListener('input', function(e) {
        const target = e.target;
        
        // Проверяем, что это поле ввода доступного времени участника
        if (target.closest('tr') && target.classList.contains('hp-input-sm') && 
            (target.previousElementSibling?.textContent === 'ч' || 
             target.nextElementSibling?.textContent === 'м')) {
            
            // Находим ID участника из строки таблицы
            const row = target.closest('tr');
            const nameInput = row.querySelector('input[type="text"]');
            if (nameInput) {
                // Находим участника по имени (или можно добавить data-id)
                const partName = nameInput.value;
                const participant = state.part.find(p => p.name === partName);
                
                if (participant) {
                    // Находим оба поля времени
                    const hoursInput = row.querySelector('input[type="number"]:nth-of-type(1)');
                    const minutesInput = row.querySelector('input[type="number"]:nth-of-type(2)');
                    
                    if (hoursInput && minutesInput) {
                        // Обновляем значение с небольшой задержкой
                        setTimeout(() => {
                            updateParticipantAvailableTime(
                                participant.id, 
                                hoursInput, 
                                minutesInput
                            );
                        }, 300);
                    }
                }
            }
        }
    });
    
    // Также обрабатываем событие change
    document.addEventListener('change', function(e) {
        const target = e.target;
        if (target.closest('tr') && target.classList.contains('hp-input-sm') && 
            (target.previousElementSibling?.textContent === 'ч' || 
             target.nextElementSibling?.textContent === 'м')) {
            
            const row = target.closest('tr');
            const hoursInput = row.querySelector('input[type="number"]:nth-of-type(1)');
            const minutesInput = row.querySelector('input[type="number"]:nth-of-type(2)');
            
            if (hoursInput && minutesInput) {
                const partName = row.querySelector('input[type="text"]').value;
                const participant = state.part.find(p => p.name === partName);
                
                if (participant) {
                    setTimeout(() => {
                        updateParticipantAvailableTime(
                            participant.id, 
                            hoursInput, 
                            minutesInput
                        );
                    }, 100);
                }
            }
        }
    });
});


// Добавьте эту функцию для обработки событий нажатия Enter в полях вероятности
document.addEventListener('keydown', function(event) {
    if (event.target.classList.contains('probability-input') && event.key === 'Enter') {
        event.preventDefault();
        const itemId = parseInt(event.target.getAttribute('data-item-id'));
        const parentId = parseInt(event.target.getAttribute('data-parent-id'));
        const value = event.target.value;
        
        app.updateItemProbability(itemId, value, parentId);
        event.target.blur();
    }
});

// Также обрабатываем потерю фокуса
document.addEventListener('blur', function(event) {
    if (event.target.classList.contains('probability-input')) {
        const itemId = parseInt(event.target.getAttribute('data-item-id'));
        const parentId = parseInt(event.target.getAttribute('data-parent-id'));
        const value = event.target.value;
        
        // Небольшая задержка для избежания двойного вызова
        setTimeout(() => {
            app.updateItemProbability(itemId, value, parentId);
        }, 100);
    }
}, true);



</script></body></html>
